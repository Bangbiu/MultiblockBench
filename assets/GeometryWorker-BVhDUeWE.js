var fr=Object.defineProperty;var mr=(Rt,Nt,le)=>Nt in Rt?fr(Rt,Nt,{enumerable:!0,configurable:!0,writable:!0,value:le}):Rt[Nt]=le;var J=(Rt,Nt,le)=>mr(Rt,typeof Nt!="symbol"?Nt+"":Nt,le);(function(){"use strict";/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Rt="177",Xs="",yt="srgb",Ys="srgb-linear",$s="linear",ts="srgb";class Fe{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return s===void 0?!1:s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){const s=this._listeners;if(s===void 0)return;const i=s[t];if(i!==void 0){const n=i.indexOf(e);n!==-1&&i.splice(n,1)}}dispatchEvent(t){const e=this._listeners;if(e===void 0)return;const s=e[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let n=0,r=i.length;n<r;n++)i[n].call(this,t);t.target=null}}}const rt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function $t(){const l=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(rt[l&255]+rt[l>>8&255]+rt[l>>16&255]+rt[l>>24&255]+"-"+rt[t&255]+rt[t>>8&255]+"-"+rt[t>>16&15|64]+rt[t>>24&255]+"-"+rt[e&63|128]+rt[e>>8&255]+"-"+rt[e>>16&255]+rt[e>>24&255]+rt[s&255]+rt[s>>8&255]+rt[s>>16&255]+rt[s>>24&255]).toLowerCase()}function N(l,t,e){return Math.max(t,Math.min(e,l))}function Hi(l,t){return(l%t+t)%t}function es(l,t,e){return(1-e)*l+e*t}function ue(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return l/4294967295;case Uint16Array:return l/65535;case Uint8Array:return l/255;case Int32Array:return Math.max(l/2147483647,-1);case Int16Array:return Math.max(l/32767,-1);case Int8Array:return Math.max(l/127,-1);default:throw new Error("Invalid component type.")}}function ht(l,t){switch(t.constructor){case Float32Array:return l;case Uint32Array:return Math.round(l*4294967295);case Uint16Array:return Math.round(l*65535);case Uint8Array:return Math.round(l*255);case Int32Array:return Math.round(l*2147483647);case Int16Array:return Math.round(l*32767);case Int8Array:return Math.round(l*127);default:throw new Error("Invalid component type.")}}class T{constructor(t=0,e=0){T.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6],this.y=i[1]*e+i[4]*s+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=N(this.x,t.x,e.x),this.y=N(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=N(this.x,t,e),this.y=N(this.y,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(N(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(N(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),i=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*s-r*i+t.x,this.y=n*i+r*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class pe{constructor(t=0,e=0,s=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=i}static slerpFlat(t,e,s,i,n,r,o){let h=s[i+0],c=s[i+1],a=s[i+2],u=s[i+3];const d=n[r+0],p=n[r+1],f=n[r+2],m=n[r+3];if(o===0){t[e+0]=h,t[e+1]=c,t[e+2]=a,t[e+3]=u;return}if(o===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(u!==m||h!==d||c!==p||a!==f){let y=1-o;const M=h*d+c*p+a*f+u*m,g=M>=0?1:-1,w=1-M*M;if(w>Number.EPSILON){const z=Math.sqrt(w),A=Math.atan2(z,M*g);y=Math.sin(y*A)/z,o=Math.sin(o*A)/z}const x=o*g;if(h=h*y+d*x,c=c*y+p*x,a=a*y+f*x,u=u*y+m*x,y===1-o){const z=1/Math.sqrt(h*h+c*c+a*a+u*u);h*=z,c*=z,a*=z,u*=z}}t[e]=h,t[e+1]=c,t[e+2]=a,t[e+3]=u}static multiplyQuaternionsFlat(t,e,s,i,n,r){const o=s[i],h=s[i+1],c=s[i+2],a=s[i+3],u=n[r],d=n[r+1],p=n[r+2],f=n[r+3];return t[e]=o*f+a*u+h*p-c*d,t[e+1]=h*f+a*d+c*u-o*p,t[e+2]=c*f+a*p+o*d-h*u,t[e+3]=a*f-o*u-h*d-c*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,i){return this._x=t,this._y=e,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const s=t._x,i=t._y,n=t._z,r=t._order,o=Math.cos,h=Math.sin,c=o(s/2),a=o(i/2),u=o(n/2),d=h(s/2),p=h(i/2),f=h(n/2);switch(r){case"XYZ":this._x=d*a*u+c*p*f,this._y=c*p*u-d*a*f,this._z=c*a*f+d*p*u,this._w=c*a*u-d*p*f;break;case"YXZ":this._x=d*a*u+c*p*f,this._y=c*p*u-d*a*f,this._z=c*a*f-d*p*u,this._w=c*a*u+d*p*f;break;case"ZXY":this._x=d*a*u-c*p*f,this._y=c*p*u+d*a*f,this._z=c*a*f+d*p*u,this._w=c*a*u-d*p*f;break;case"ZYX":this._x=d*a*u-c*p*f,this._y=c*p*u+d*a*f,this._z=c*a*f-d*p*u,this._w=c*a*u+d*p*f;break;case"YZX":this._x=d*a*u+c*p*f,this._y=c*p*u+d*a*f,this._z=c*a*f-d*p*u,this._w=c*a*u-d*p*f;break;case"XZY":this._x=d*a*u-c*p*f,this._y=c*p*u-d*a*f,this._z=c*a*f+d*p*u,this._w=c*a*u+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,i=Math.sin(s);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],i=e[4],n=e[8],r=e[1],o=e[5],h=e[9],c=e[2],a=e[6],u=e[10],d=s+o+u;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(a-h)*p,this._y=(n-c)*p,this._z=(r-i)*p}else if(s>o&&s>u){const p=2*Math.sqrt(1+s-o-u);this._w=(a-h)/p,this._x=.25*p,this._y=(i+r)/p,this._z=(n+c)/p}else if(o>u){const p=2*Math.sqrt(1+o-s-u);this._w=(n-c)/p,this._x=(i+r)/p,this._y=.25*p,this._z=(h+a)/p}else{const p=2*Math.sqrt(1+u-s-o);this._w=(r-i)/p,this._x=(n+c)/p,this._y=(h+a)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(N(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(s===0)return this;const i=Math.min(1,e/s);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,i=t._y,n=t._z,r=t._w,o=e._x,h=e._y,c=e._z,a=e._w;return this._x=s*a+r*o+i*c-n*h,this._y=i*a+r*h+n*o-s*c,this._z=n*a+r*c+s*h-i*o,this._w=r*a-s*o-i*h-n*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const s=this._x,i=this._y,n=this._z,r=this._w;let o=r*t._w+s*t._x+i*t._y+n*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=r,this._x=s,this._y=i,this._z=n,this;const h=1-o*o;if(h<=Number.EPSILON){const p=1-e;return this._w=p*r+e*this._w,this._x=p*s+e*this._x,this._y=p*i+e*this._y,this._z=p*n+e*this._z,this.normalize(),this}const c=Math.sqrt(h),a=Math.atan2(c,o),u=Math.sin((1-e)*a)/c,d=Math.sin(e*a)/c;return this._w=r*u+this._w*d,this._x=s*u+this._x*d,this._y=i*u+this._y*d,this._z=n*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),s=Math.random(),i=Math.sqrt(1-s),n=Math.sqrt(s);return this.set(i*Math.sin(t),i*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class b{constructor(t=0,e=0,s=0){b.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return s===void 0&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(js.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(js.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,i=this.z,n=t.elements;return this.x=n[0]*e+n[3]*s+n[6]*i,this.y=n[1]*e+n[4]*s+n[7]*i,this.z=n[2]*e+n[5]*s+n[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,n=t.elements,r=1/(n[3]*e+n[7]*s+n[11]*i+n[15]);return this.x=(n[0]*e+n[4]*s+n[8]*i+n[12])*r,this.y=(n[1]*e+n[5]*s+n[9]*i+n[13])*r,this.z=(n[2]*e+n[6]*s+n[10]*i+n[14])*r,this}applyQuaternion(t){const e=this.x,s=this.y,i=this.z,n=t.x,r=t.y,o=t.z,h=t.w,c=2*(r*i-o*s),a=2*(o*e-n*i),u=2*(n*s-r*e);return this.x=e+h*c+r*u-o*a,this.y=s+h*a+o*c-n*u,this.z=i+h*u+n*a-r*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,i=this.z,n=t.elements;return this.x=n[0]*e+n[4]*s+n[8]*i,this.y=n[1]*e+n[5]*s+n[9]*i,this.z=n[2]*e+n[6]*s+n[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=N(this.x,t.x,e.x),this.y=N(this.y,t.y,e.y),this.z=N(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=N(this.x,t,e),this.y=N(this.y,t,e),this.z=N(this.z,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(N(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,i=t.y,n=t.z,r=e.x,o=e.y,h=e.z;return this.x=i*h-n*o,this.y=n*r-s*h,this.z=s*o-i*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return ss.copy(this).projectOnVector(t),this.sub(ss)}reflect(t){return this.sub(ss.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(N(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,s=Math.sqrt(1-e*e);return this.x=s*Math.cos(t),this.y=e,this.z=s*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ss=new b,js=new pe;class St{constructor(t,e,s,i,n,r,o,h,c){St.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,s,i,n,r,o,h,c)}set(t,e,s,i,n,r,o,h,c){const a=this.elements;return a[0]=t,a[1]=i,a[2]=o,a[3]=e,a[4]=n,a[5]=h,a[6]=s,a[7]=r,a[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,n=this.elements,r=s[0],o=s[3],h=s[6],c=s[1],a=s[4],u=s[7],d=s[2],p=s[5],f=s[8],m=i[0],y=i[3],M=i[6],g=i[1],w=i[4],x=i[7],z=i[2],A=i[5],v=i[8];return n[0]=r*m+o*g+h*z,n[3]=r*y+o*w+h*A,n[6]=r*M+o*x+h*v,n[1]=c*m+a*g+u*z,n[4]=c*y+a*w+u*A,n[7]=c*M+a*x+u*v,n[2]=d*m+p*g+f*z,n[5]=d*y+p*w+f*A,n[8]=d*M+p*x+f*v,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],i=t[2],n=t[3],r=t[4],o=t[5],h=t[6],c=t[7],a=t[8];return e*r*a-e*o*c-s*n*a+s*o*h+i*n*c-i*r*h}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],n=t[3],r=t[4],o=t[5],h=t[6],c=t[7],a=t[8],u=a*r-o*c,d=o*h-a*n,p=c*n-r*h,f=e*u+s*d+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=u*m,t[1]=(i*c-a*s)*m,t[2]=(o*s-i*r)*m,t[3]=d*m,t[4]=(a*e-i*h)*m,t[5]=(i*n-o*e)*m,t[6]=p*m,t[7]=(s*h-c*e)*m,t[8]=(r*e-s*n)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,i,n,r,o){const h=Math.cos(n),c=Math.sin(n);return this.set(s*h,s*c,-s*(h*r+c*o)+r+t,-i*c,i*h,-i*(-c*r+h*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(is.makeScale(t,e)),this}rotate(t){return this.premultiply(is.makeRotation(-t)),this}translate(t,e){return this.premultiply(is.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<9;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const is=new St;function Zi(l){for(let t=l.length-1;t>=0;--t)if(l[t]>=65535)return!0;return!1}function Qs(l){return document.createElementNS("http://www.w3.org/1999/xhtml",l)}const Ks={};function ti(l){l in Ks||(Ks[l]=!0,console.warn(l))}const ei=new St().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),si=new St().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Xi(){const l={enabled:!0,workingColorSpace:Ys,spaces:{},convert:function(i,n,r){return this.enabled===!1||n===r||!n||!r||(this.spaces[n].transfer===ts&&(i.r=vt(i.r),i.g=vt(i.g),i.b=vt(i.b)),this.spaces[n].primaries!==this.spaces[r].primaries&&(i.applyMatrix3(this.spaces[n].toXYZ),i.applyMatrix3(this.spaces[r].fromXYZ)),this.spaces[r].transfer===ts&&(i.r=jt(i.r),i.g=jt(i.g),i.b=jt(i.b))),i},workingToColorSpace:function(i,n){return this.convert(i,this.workingColorSpace,n)},colorSpaceToWorking:function(i,n){return this.convert(i,n,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Xs?$s:this.spaces[i].transfer},getLuminanceCoefficients:function(i,n=this.workingColorSpace){return i.fromArray(this.spaces[n].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,n,r){return i.copy(this.spaces[n].toXYZ).multiply(this.spaces[r].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,n){return ti("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),l.workingToColorSpace(i,n)},toWorkingColorSpace:function(i,n){return ti("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),l.colorSpaceToWorking(i,n)}},t=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],s=[.3127,.329];return l.define({[Ys]:{primaries:t,whitePoint:s,transfer:$s,toXYZ:ei,fromXYZ:si,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:yt},outputColorSpaceConfig:{drawingBufferColorSpace:yt}},[yt]:{primaries:t,whitePoint:s,transfer:ts,toXYZ:ei,fromXYZ:si,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:yt}}}),l}const xt=Xi();function vt(l){return l<.04045?l*.0773993808:Math.pow(l*.9478672986+.0521327014,2.4)}function jt(l){return l<.0031308?l*12.92:1.055*Math.pow(l,.41666)-.055}let Qt;class Yi{static getDataURL(t,e="image/png"){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let s;if(t instanceof HTMLCanvasElement)s=t;else{Qt===void 0&&(Qt=Qs("canvas")),Qt.width=t.width,Qt.height=t.height;const i=Qt.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),s=Qt}return s.toDataURL(e)}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Qs("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height),n=i.data;for(let r=0;r<n.length;r++)n[r]=vt(n[r]/255)*255;return s.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let s=0;s<e.length;s++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[s]=Math.floor(vt(e[s]/255)*255):e[s]=vt(e[s]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let $i=0;class ji{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:$i++}),this.uuid=$t(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const e=this.data;return e instanceof HTMLVideoElement?t.set(e.videoWidth,e.videoHeight):e!==null?t.set(e.width,e.height,e.depth||0):t.set(0,0,0),t}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let n;if(Array.isArray(i)){n=[];for(let r=0,o=i.length;r<o;r++)i[r].isDataTexture?n.push(ns(i[r].image)):n.push(ns(i[r]))}else n=ns(i);s.url=n}return e||(t.images[this.uuid]=s),s}}function ns(l){return typeof HTMLImageElement<"u"&&l instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&l instanceof ImageBitmap?Yi.getDataURL(l):l.data?{data:Array.from(l.data),width:l.width,height:l.height,type:l.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Qi=0;const rs=new b;class Ut extends Fe{constructor(t=Ut.DEFAULT_IMAGE,e=Ut.DEFAULT_MAPPING,s=1001,i=1001,n=1006,r=1008,o=1023,h=1009,c=Ut.DEFAULT_ANISOTROPY,a=Xs){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Qi++}),this.uuid=$t(),this.name="",this.source=new ji(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=n,this.minFilter=r,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=h,this.offset=new T(0,0),this.repeat=new T(1,1),this.center=new T(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new St,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=a,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(rs).x}get height(){return this.source.getSize(rs).y}get depth(){return this.source.getSize(rs).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const e in t){const s=t[e];if(s===void 0){console.warn(`THREE.Texture.setValues(): parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){console.warn(`THREE.Texture.setValues(): property '${e}' does not exist.`);continue}i&&s&&i.isVector2&&s.isVector2||i&&s&&i.isVector3&&s.isVector3||i&&s&&i.isMatrix3&&s.isMatrix3?i.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const s={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}Ut.DEFAULT_IMAGE=null,Ut.DEFAULT_MAPPING=300,Ut.DEFAULT_ANISOTROPY=1;class de{constructor(t=0,e=0,s=0,i=1){de.prototype.isVector4=!0,this.x=t,this.y=e,this.z=s,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i+r[12]*n,this.y=r[1]*e+r[5]*s+r[9]*i+r[13]*n,this.z=r[2]*e+r[6]*s+r[10]*i+r[14]*n,this.w=r[3]*e+r[7]*s+r[11]*i+r[15]*n,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,s,i,n;const h=t.elements,c=h[0],a=h[4],u=h[8],d=h[1],p=h[5],f=h[9],m=h[2],y=h[6],M=h[10];if(Math.abs(a-d)<.01&&Math.abs(u-m)<.01&&Math.abs(f-y)<.01){if(Math.abs(a+d)<.1&&Math.abs(u+m)<.1&&Math.abs(f+y)<.1&&Math.abs(c+p+M-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const w=(c+1)/2,x=(p+1)/2,z=(M+1)/2,A=(a+d)/4,v=(u+m)/4,S=(f+y)/4;return w>x&&w>z?w<.01?(s=0,i=.707106781,n=.707106781):(s=Math.sqrt(w),i=A/s,n=v/s):x>z?x<.01?(s=.707106781,i=0,n=.707106781):(i=Math.sqrt(x),s=A/i,n=S/i):z<.01?(s=.707106781,i=.707106781,n=0):(n=Math.sqrt(z),s=v/n,i=S/n),this.set(s,i,n,e),this}let g=Math.sqrt((y-f)*(y-f)+(u-m)*(u-m)+(d-a)*(d-a));return Math.abs(g)<.001&&(g=1),this.x=(y-f)/g,this.y=(u-m)/g,this.z=(d-a)/g,this.w=Math.acos((c+p+M-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=N(this.x,t.x,e.x),this.y=N(this.y,t.y,e.y),this.z=N(this.z,t.z,e.z),this.w=N(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=N(this.x,t,e),this.y=N(this.y,t,e),this.z=N(this.z,t,e),this.w=N(this.w,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(N(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this.w=t.w+(e.w-t.w)*s,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class fe{constructor(t=new b(1/0,1/0,1/0),e=new b(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e+=3)this.expandByPoint(gt.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,s=t.count;e<s;e++)this.expandByPoint(gt.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=gt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(s!==void 0){const n=s.getAttribute("position");if(e===!0&&n!==void 0&&t.isInstancedMesh!==!0)for(let r=0,o=n.count;r<o;r++)t.isMesh===!0?t.getVertexPosition(r,gt):gt.fromBufferAttribute(n,r),gt.applyMatrix4(t.matrixWorld),this.expandByPoint(gt);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Te.copy(t.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Te.copy(s.boundingBox)),Te.applyMatrix4(t.matrixWorld),this.union(Te)}const i=t.children;for(let n=0,r=i.length;n<r;n++)this.expandByObject(i[n],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,gt),gt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(me),Be.subVectors(this.max,me),Kt.subVectors(t.a,me),te.subVectors(t.b,me),ee.subVectors(t.c,me),Dt.subVectors(te,Kt),Lt.subVectors(ee,te),Wt.subVectors(Kt,ee);let e=[0,-Dt.z,Dt.y,0,-Lt.z,Lt.y,0,-Wt.z,Wt.y,Dt.z,0,-Dt.x,Lt.z,0,-Lt.x,Wt.z,0,-Wt.x,-Dt.y,Dt.x,0,-Lt.y,Lt.x,0,-Wt.y,Wt.x,0];return!os(e,Kt,te,ee,Be)||(e=[1,0,0,0,1,0,0,0,1],!os(e,Kt,te,ee,Be))?!1:(Ee.crossVectors(Dt,Lt),e=[Ee.x,Ee.y,Ee.z],os(e,Kt,te,ee,Be))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,gt).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(gt).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(_t[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),_t[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),_t[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),_t[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),_t[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),_t[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),_t[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),_t[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(_t),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const _t=[new b,new b,new b,new b,new b,new b,new b,new b],gt=new b,Te=new fe,Kt=new b,te=new b,ee=new b,Dt=new b,Lt=new b,Wt=new b,me=new b,Be=new b,Ee=new b,Gt=new b;function os(l,t,e,s,i){for(let n=0,r=l.length-3;n<=r;n+=3){Gt.fromArray(l,n);const o=i.x*Math.abs(Gt.x)+i.y*Math.abs(Gt.y)+i.z*Math.abs(Gt.z),h=t.dot(Gt),c=e.dot(Gt),a=s.dot(Gt);if(Math.max(-Math.max(h,c,a),Math.min(h,c,a))>o)return!1}return!0}const Ki=new fe,ye=new b,hs=new b;class ii{constructor(t=new b,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;e!==void 0?s.copy(e):Ki.setFromPoints(t).getCenter(s);let i=0;for(let n=0,r=t.length;n<r;n++)i=Math.max(i,s.distanceToSquared(t[n]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;ye.subVectors(t,this.center);const e=ye.lengthSq();if(e>this.radius*this.radius){const s=Math.sqrt(e),i=(s-this.radius)*.5;this.center.addScaledVector(ye,i/s),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(hs.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(ye.copy(t.center).add(hs)),this.expandByPoint(ye.copy(t.center).sub(hs))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const Ct=new b,as=new b,Pe=new b,Vt=new b,cs=new b,ke=new b,ls=new b;class tn{constructor(t=new b,e=new b(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Ct)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const s=e.dot(this.direction);return s<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Ct.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Ct.copy(this.origin).addScaledVector(this.direction,e),Ct.distanceToSquared(t))}distanceSqToSegment(t,e,s,i){as.copy(t).add(e).multiplyScalar(.5),Pe.copy(e).sub(t).normalize(),Vt.copy(this.origin).sub(as);const n=t.distanceTo(e)*.5,r=-this.direction.dot(Pe),o=Vt.dot(this.direction),h=-Vt.dot(Pe),c=Vt.lengthSq(),a=Math.abs(1-r*r);let u,d,p,f;if(a>0)if(u=r*h-o,d=r*o-h,f=n*a,u>=0)if(d>=-f)if(d<=f){const m=1/a;u*=m,d*=m,p=u*(u+r*d+2*o)+d*(r*u+d+2*h)+c}else d=n,u=Math.max(0,-(r*d+o)),p=-u*u+d*(d+2*h)+c;else d=-n,u=Math.max(0,-(r*d+o)),p=-u*u+d*(d+2*h)+c;else d<=-f?(u=Math.max(0,-(-r*n+o)),d=u>0?-n:Math.min(Math.max(-n,-h),n),p=-u*u+d*(d+2*h)+c):d<=f?(u=0,d=Math.min(Math.max(-n,-h),n),p=d*(d+2*h)+c):(u=Math.max(0,-(r*n+o)),d=u>0?n:Math.min(Math.max(-n,-h),n),p=-u*u+d*(d+2*h)+c);else d=r>0?-n:n,u=Math.max(0,-(r*d+o)),p=-u*u+d*(d+2*h)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,u),i&&i.copy(as).addScaledVector(Pe,d),p}intersectSphere(t,e){Ct.subVectors(t.center,this.origin);const s=Ct.dot(this.direction),i=Ct.dot(Ct)-s*s,n=t.radius*t.radius;if(i>n)return null;const r=Math.sqrt(n-i),o=s-r,h=s+r;return h<0?null:o<0?this.at(h,e):this.at(o,e)}intersectsSphere(t){return t.radius<0?!1:this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/e;return s>=0?s:null}intersectPlane(t,e){const s=this.distanceToPlane(t);return s===null?null:this.at(s,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let s,i,n,r,o,h;const c=1/this.direction.x,a=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(s=(t.min.x-d.x)*c,i=(t.max.x-d.x)*c):(s=(t.max.x-d.x)*c,i=(t.min.x-d.x)*c),a>=0?(n=(t.min.y-d.y)*a,r=(t.max.y-d.y)*a):(n=(t.max.y-d.y)*a,r=(t.min.y-d.y)*a),s>r||n>i||((n>s||isNaN(s))&&(s=n),(r<i||isNaN(i))&&(i=r),u>=0?(o=(t.min.z-d.z)*u,h=(t.max.z-d.z)*u):(o=(t.max.z-d.z)*u,h=(t.min.z-d.z)*u),s>h||o>i)||((o>s||s!==s)&&(s=o),(h<i||i!==i)&&(i=h),i<0)?null:this.at(s>=0?s:i,e)}intersectsBox(t){return this.intersectBox(t,Ct)!==null}intersectTriangle(t,e,s,i,n){cs.subVectors(e,t),ke.subVectors(s,t),ls.crossVectors(cs,ke);let r=this.direction.dot(ls),o;if(r>0){if(i)return null;o=1}else if(r<0)o=-1,r=-r;else return null;Vt.subVectors(this.origin,t);const h=o*this.direction.dot(ke.crossVectors(Vt,ke));if(h<0)return null;const c=o*this.direction.dot(cs.cross(Vt));if(c<0||h+c>r)return null;const a=-o*Vt.dot(ls);return a<0?null:this.at(a/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class pt{constructor(t,e,s,i,n,r,o,h,c,a,u,d,p,f,m,y){pt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,s,i,n,r,o,h,c,a,u,d,p,f,m,y)}set(t,e,s,i,n,r,o,h,c,a,u,d,p,f,m,y){const M=this.elements;return M[0]=t,M[4]=e,M[8]=s,M[12]=i,M[1]=n,M[5]=r,M[9]=o,M[13]=h,M[2]=c,M[6]=a,M[10]=u,M[14]=d,M[3]=p,M[7]=f,M[11]=m,M[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new pt().fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,i=1/se.setFromMatrixColumn(t,0).length(),n=1/se.setFromMatrixColumn(t,1).length(),r=1/se.setFromMatrixColumn(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=0,e[4]=s[4]*n,e[5]=s[5]*n,e[6]=s[6]*n,e[7]=0,e[8]=s[8]*r,e[9]=s[9]*r,e[10]=s[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,i=t.y,n=t.z,r=Math.cos(s),o=Math.sin(s),h=Math.cos(i),c=Math.sin(i),a=Math.cos(n),u=Math.sin(n);if(t.order==="XYZ"){const d=r*a,p=r*u,f=o*a,m=o*u;e[0]=h*a,e[4]=-h*u,e[8]=c,e[1]=p+f*c,e[5]=d-m*c,e[9]=-o*h,e[2]=m-d*c,e[6]=f+p*c,e[10]=r*h}else if(t.order==="YXZ"){const d=h*a,p=h*u,f=c*a,m=c*u;e[0]=d+m*o,e[4]=f*o-p,e[8]=r*c,e[1]=r*u,e[5]=r*a,e[9]=-o,e[2]=p*o-f,e[6]=m+d*o,e[10]=r*h}else if(t.order==="ZXY"){const d=h*a,p=h*u,f=c*a,m=c*u;e[0]=d-m*o,e[4]=-r*u,e[8]=f+p*o,e[1]=p+f*o,e[5]=r*a,e[9]=m-d*o,e[2]=-r*c,e[6]=o,e[10]=r*h}else if(t.order==="ZYX"){const d=r*a,p=r*u,f=o*a,m=o*u;e[0]=h*a,e[4]=f*c-p,e[8]=d*c+m,e[1]=h*u,e[5]=m*c+d,e[9]=p*c-f,e[2]=-c,e[6]=o*h,e[10]=r*h}else if(t.order==="YZX"){const d=r*h,p=r*c,f=o*h,m=o*c;e[0]=h*a,e[4]=m-d*u,e[8]=f*u+p,e[1]=u,e[5]=r*a,e[9]=-o*a,e[2]=-c*a,e[6]=p*u+f,e[10]=d-m*u}else if(t.order==="XZY"){const d=r*h,p=r*c,f=o*h,m=o*c;e[0]=h*a,e[4]=-u,e[8]=c*a,e[1]=d*u+m,e[5]=r*a,e[9]=p*u-f,e[2]=f*u-p,e[6]=o*a,e[10]=m*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(en,t,sn)}lookAt(t,e,s){const i=this.elements;return at.subVectors(t,e),at.lengthSq()===0&&(at.z=1),at.normalize(),qt.crossVectors(s,at),qt.lengthSq()===0&&(Math.abs(s.z)===1?at.x+=1e-4:at.z+=1e-4,at.normalize(),qt.crossVectors(s,at)),qt.normalize(),Ie.crossVectors(at,qt),i[0]=qt.x,i[4]=Ie.x,i[8]=at.x,i[1]=qt.y,i[5]=Ie.y,i[9]=at.y,i[2]=qt.z,i[6]=Ie.z,i[10]=at.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,n=this.elements,r=s[0],o=s[4],h=s[8],c=s[12],a=s[1],u=s[5],d=s[9],p=s[13],f=s[2],m=s[6],y=s[10],M=s[14],g=s[3],w=s[7],x=s[11],z=s[15],A=i[0],v=i[4],S=i[8],C=i[12],_=i[1],P=i[5],O=i[9],D=i[13],G=i[2],U=i[6],tt=i[10],nt=i[14],Mt=i[3],$=i[7],K=i[11],j=i[15];return n[0]=r*A+o*_+h*G+c*Mt,n[4]=r*v+o*P+h*U+c*$,n[8]=r*S+o*O+h*tt+c*K,n[12]=r*C+o*D+h*nt+c*j,n[1]=a*A+u*_+d*G+p*Mt,n[5]=a*v+u*P+d*U+p*$,n[9]=a*S+u*O+d*tt+p*K,n[13]=a*C+u*D+d*nt+p*j,n[2]=f*A+m*_+y*G+M*Mt,n[6]=f*v+m*P+y*U+M*$,n[10]=f*S+m*O+y*tt+M*K,n[14]=f*C+m*D+y*nt+M*j,n[3]=g*A+w*_+x*G+z*Mt,n[7]=g*v+w*P+x*U+z*$,n[11]=g*S+w*O+x*tt+z*K,n[15]=g*C+w*D+x*nt+z*j,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],i=t[8],n=t[12],r=t[1],o=t[5],h=t[9],c=t[13],a=t[2],u=t[6],d=t[10],p=t[14],f=t[3],m=t[7],y=t[11],M=t[15];return f*(+n*h*u-i*c*u-n*o*d+s*c*d+i*o*p-s*h*p)+m*(+e*h*p-e*c*d+n*r*d-i*r*p+i*c*a-n*h*a)+y*(+e*c*u-e*o*p-n*r*u+s*r*p+n*o*a-s*c*a)+M*(-i*o*a-e*h*u+e*o*d+i*r*u-s*r*d+s*h*a)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],n=t[3],r=t[4],o=t[5],h=t[6],c=t[7],a=t[8],u=t[9],d=t[10],p=t[11],f=t[12],m=t[13],y=t[14],M=t[15],g=u*y*c-m*d*c+m*h*p-o*y*p-u*h*M+o*d*M,w=f*d*c-a*y*c-f*h*p+r*y*p+a*h*M-r*d*M,x=a*m*c-f*u*c+f*o*p-r*m*p-a*o*M+r*u*M,z=f*u*h-a*m*h-f*o*d+r*m*d+a*o*y-r*u*y,A=e*g+s*w+i*x+n*z;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const v=1/A;return t[0]=g*v,t[1]=(m*d*n-u*y*n-m*i*p+s*y*p+u*i*M-s*d*M)*v,t[2]=(o*y*n-m*h*n+m*i*c-s*y*c-o*i*M+s*h*M)*v,t[3]=(u*h*n-o*d*n-u*i*c+s*d*c+o*i*p-s*h*p)*v,t[4]=w*v,t[5]=(a*y*n-f*d*n+f*i*p-e*y*p-a*i*M+e*d*M)*v,t[6]=(f*h*n-r*y*n-f*i*c+e*y*c+r*i*M-e*h*M)*v,t[7]=(r*d*n-a*h*n+a*i*c-e*d*c-r*i*p+e*h*p)*v,t[8]=x*v,t[9]=(f*u*n-a*m*n-f*s*p+e*m*p+a*s*M-e*u*M)*v,t[10]=(r*m*n-f*o*n+f*s*c-e*m*c-r*s*M+e*o*M)*v,t[11]=(a*o*n-r*u*n-a*s*c+e*u*c+r*s*p-e*o*p)*v,t[12]=z*v,t[13]=(a*m*i-f*u*i+f*s*d-e*m*d-a*s*y+e*u*y)*v,t[14]=(f*o*i-r*m*i-f*s*h+e*m*h+r*s*y-e*o*y)*v,t[15]=(r*u*i-a*o*i+a*s*h-e*u*h-r*s*d+e*o*d)*v,this}scale(t){const e=this.elements,s=t.x,i=t.y,n=t.z;return e[0]*=s,e[4]*=i,e[8]*=n,e[1]*=s,e[5]*=i,e[9]*=n,e[2]*=s,e[6]*=i,e[10]*=n,e[3]*=s,e[7]*=i,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}makeTranslation(t,e,s){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),n=1-s,r=t.x,o=t.y,h=t.z,c=n*r,a=n*o;return this.set(c*r+s,c*o-i*h,c*h+i*o,0,c*o+i*h,a*o+s,a*h-i*r,0,c*h-i*o,a*h+i*r,n*h*h+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,n,r){return this.set(1,s,n,0,t,1,r,0,e,i,1,0,0,0,0,1),this}compose(t,e,s){const i=this.elements,n=e._x,r=e._y,o=e._z,h=e._w,c=n+n,a=r+r,u=o+o,d=n*c,p=n*a,f=n*u,m=r*a,y=r*u,M=o*u,g=h*c,w=h*a,x=h*u,z=s.x,A=s.y,v=s.z;return i[0]=(1-(m+M))*z,i[1]=(p+x)*z,i[2]=(f-w)*z,i[3]=0,i[4]=(p-x)*A,i[5]=(1-(d+M))*A,i[6]=(y+g)*A,i[7]=0,i[8]=(f+w)*v,i[9]=(y-g)*v,i[10]=(1-(d+m))*v,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){const i=this.elements;let n=se.set(i[0],i[1],i[2]).length();const r=se.set(i[4],i[5],i[6]).length(),o=se.set(i[8],i[9],i[10]).length();this.determinant()<0&&(n=-n),t.x=i[12],t.y=i[13],t.z=i[14],wt.copy(this);const c=1/n,a=1/r,u=1/o;return wt.elements[0]*=c,wt.elements[1]*=c,wt.elements[2]*=c,wt.elements[4]*=a,wt.elements[5]*=a,wt.elements[6]*=a,wt.elements[8]*=u,wt.elements[9]*=u,wt.elements[10]*=u,e.setFromRotationMatrix(wt),s.x=n,s.y=r,s.z=o,this}makePerspective(t,e,s,i,n,r,o=2e3){const h=this.elements,c=2*n/(e-t),a=2*n/(s-i),u=(e+t)/(e-t),d=(s+i)/(s-i);let p,f;if(o===2e3)p=-(r+n)/(r-n),f=-2*r*n/(r-n);else if(o===2001)p=-r/(r-n),f=-r*n/(r-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return h[0]=c,h[4]=0,h[8]=u,h[12]=0,h[1]=0,h[5]=a,h[9]=d,h[13]=0,h[2]=0,h[6]=0,h[10]=p,h[14]=f,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,s,i,n,r,o=2e3){const h=this.elements,c=1/(e-t),a=1/(s-i),u=1/(r-n),d=(e+t)*c,p=(s+i)*a;let f,m;if(o===2e3)f=(r+n)*u,m=-2*u;else if(o===2001)f=n*u,m=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return h[0]=2*c,h[4]=0,h[8]=0,h[12]=-d,h[1]=0,h[5]=2*a,h[9]=0,h[13]=-p,h[2]=0,h[6]=0,h[10]=m,h[14]=-f,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<16;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const se=new b,wt=new pt,en=new b(0,0,0),sn=new b(1,1,1),qt=new b,Ie=new b,at=new b,ni=new pt,ri=new pe;class xe{constructor(t=0,e=0,s=0,i=xe.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,i=this._order){return this._x=t,this._y=e,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const i=t.elements,n=i[0],r=i[4],o=i[8],h=i[1],c=i[5],a=i[9],u=i[2],d=i[6],p=i[10];switch(e){case"XYZ":this._y=Math.asin(N(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-a,p),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-N(a,-1,1)),Math.abs(a)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(h,c)):(this._y=Math.atan2(-u,n),this._z=0);break;case"ZXY":this._x=Math.asin(N(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(h,n));break;case"ZYX":this._y=Math.asin(-N(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(h,n)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(N(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-a,c),this._y=Math.atan2(-u,n)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-N(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,n)):(this._x=Math.atan2(-a,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,s===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return ni.makeRotationFromQuaternion(t),this.setFromRotationMatrix(ni,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return ri.setFromEuler(this),this.setFromQuaternion(ri,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}xe.DEFAULT_ORDER="XYZ";class nn{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let rn=0;const oi=new b,ie=new pe,Ft=new pt,Oe=new b,ge=new b,on=new b,hn=new pe,hi=new b(1,0,0),ai=new b(0,1,0),ci=new b(0,0,1),li={type:"added"},an={type:"removed"},ne={type:"childadded",child:null},us={type:"childremoved",child:null};class Tt extends Fe{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:rn++}),this.uuid=$t(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Tt.DEFAULT_UP.clone();const t=new b,e=new xe,s=new pe,i=new b(1,1,1);function n(){s.setFromEuler(e,!1)}function r(){e.setFromQuaternion(s,void 0,!1)}e._onChange(n),s._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new pt},normalMatrix:{value:new St}}),this.matrix=new pt,this.matrixWorld=new pt,this.matrixAutoUpdate=Tt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new nn,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ie.setFromAxisAngle(t,e),this.quaternion.multiply(ie),this}rotateOnWorldAxis(t,e){return ie.setFromAxisAngle(t,e),this.quaternion.premultiply(ie),this}rotateX(t){return this.rotateOnAxis(hi,t)}rotateY(t){return this.rotateOnAxis(ai,t)}rotateZ(t){return this.rotateOnAxis(ci,t)}translateOnAxis(t,e){return oi.copy(t).applyQuaternion(this.quaternion),this.position.add(oi.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(hi,t)}translateY(t){return this.translateOnAxis(ai,t)}translateZ(t){return this.translateOnAxis(ci,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Ft.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?Oe.copy(t):Oe.set(t,e,s);const i=this.parent;this.updateWorldMatrix(!0,!1),ge.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ft.lookAt(ge,Oe,this.up):Ft.lookAt(Oe,ge,this.up),this.quaternion.setFromRotationMatrix(Ft),i&&(Ft.extractRotation(i.matrixWorld),ie.setFromRotationMatrix(Ft),this.quaternion.premultiply(ie.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(li),ne.child=t,this.dispatchEvent(ne),ne.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(an),us.child=t,this.dispatchEvent(us),us.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Ft.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Ft.multiply(t.parent.matrixWorld)),t.applyMatrix4(Ft),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(li),ne.child=t,this.dispatchEvent(ne),ne.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,i=this.children.length;s<i;s++){const r=this.children[s].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e,s=[]){this[t]===e&&s.push(this);const i=this.children;for(let n=0,r=i.length;n<r;n++)i[n].getObjectsByProperty(t,e,s);return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ge,t,on),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ge,hn,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].updateMatrixWorld(t)}updateWorldMatrix(t,e){const s=this.parent;if(t===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let n=0,r=i.length;n<r;n++)i[n].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(o=>({...o,boundingBox:o.boundingBox?o.boundingBox.toJSON():void 0,boundingSphere:o.boundingSphere?o.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(o=>({...o})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(t),i.indirectTexture=this._indirectTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function n(o,h){return o[h.uuid]===void 0&&(o[h.uuid]=h.toJSON(t)),h.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=n(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const h=o.shapes;if(Array.isArray(h))for(let c=0,a=h.length;c<a;c++){const u=h[c];n(t.shapes,u)}else n(t.shapes,h)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let h=0,c=this.material.length;h<c;h++)o.push(n(t.materials,this.material[h]));i.material=o}else i.material=n(t.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const h=this.animations[o];i.animations.push(n(t.animations,h))}}if(e){const o=r(t.geometries),h=r(t.materials),c=r(t.textures),a=r(t.images),u=r(t.shapes),d=r(t.skeletons),p=r(t.animations),f=r(t.nodes);o.length>0&&(s.geometries=o),h.length>0&&(s.materials=h),c.length>0&&(s.textures=c),a.length>0&&(s.images=a),u.length>0&&(s.shapes=u),d.length>0&&(s.skeletons=d),p.length>0&&(s.animations=p),f.length>0&&(s.nodes=f)}return s.object=i,s;function r(o){const h=[];for(const c in o){const a=o[c];delete a.metadata,h.push(a)}return h}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let s=0;s<t.children.length;s++){const i=t.children[s];this.add(i.clone())}return this}}Tt.DEFAULT_UP=new b(0,1,0),Tt.DEFAULT_MATRIX_AUTO_UPDATE=!0,Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const bt=new b,Bt=new b,ps=new b,Et=new b,re=new b,oe=new b,ui=new b,ds=new b,fs=new b,ms=new b,ys=new de,xs=new de,gs=new de;class dt{constructor(t=new b,e=new b,s=new b){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,i){i.subVectors(s,e),bt.subVectors(t,e),i.cross(bt);const n=i.lengthSq();return n>0?i.multiplyScalar(1/Math.sqrt(n)):i.set(0,0,0)}static getBarycoord(t,e,s,i,n){bt.subVectors(i,e),Bt.subVectors(s,e),ps.subVectors(t,e);const r=bt.dot(bt),o=bt.dot(Bt),h=bt.dot(ps),c=Bt.dot(Bt),a=Bt.dot(ps),u=r*c-o*o;if(u===0)return n.set(0,0,0),null;const d=1/u,p=(c*h-o*a)*d,f=(r*a-o*h)*d;return n.set(1-p-f,f,p)}static containsPoint(t,e,s,i){return this.getBarycoord(t,e,s,i,Et)===null?!1:Et.x>=0&&Et.y>=0&&Et.x+Et.y<=1}static getInterpolation(t,e,s,i,n,r,o,h){return this.getBarycoord(t,e,s,i,Et)===null?(h.x=0,h.y=0,"z"in h&&(h.z=0),"w"in h&&(h.w=0),null):(h.setScalar(0),h.addScaledVector(n,Et.x),h.addScaledVector(r,Et.y),h.addScaledVector(o,Et.z),h)}static getInterpolatedAttribute(t,e,s,i,n,r){return ys.setScalar(0),xs.setScalar(0),gs.setScalar(0),ys.fromBufferAttribute(t,e),xs.fromBufferAttribute(t,s),gs.fromBufferAttribute(t,i),r.setScalar(0),r.addScaledVector(ys,n.x),r.addScaledVector(xs,n.y),r.addScaledVector(gs,n.z),r}static isFrontFacing(t,e,s,i){return bt.subVectors(s,e),Bt.subVectors(t,e),bt.cross(Bt).dot(i)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,i){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,s,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return bt.subVectors(this.c,this.b),Bt.subVectors(this.a,this.b),bt.cross(Bt).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return dt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return dt.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,i,n){return dt.getInterpolation(t,this.a,this.b,this.c,e,s,i,n)}containsPoint(t){return dt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return dt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,i=this.b,n=this.c;let r,o;re.subVectors(i,s),oe.subVectors(n,s),ds.subVectors(t,s);const h=re.dot(ds),c=oe.dot(ds);if(h<=0&&c<=0)return e.copy(s);fs.subVectors(t,i);const a=re.dot(fs),u=oe.dot(fs);if(a>=0&&u<=a)return e.copy(i);const d=h*u-a*c;if(d<=0&&h>=0&&a<=0)return r=h/(h-a),e.copy(s).addScaledVector(re,r);ms.subVectors(t,n);const p=re.dot(ms),f=oe.dot(ms);if(f>=0&&p<=f)return e.copy(n);const m=p*c-h*f;if(m<=0&&c>=0&&f<=0)return o=c/(c-f),e.copy(s).addScaledVector(oe,o);const y=a*f-p*u;if(y<=0&&u-a>=0&&p-f>=0)return ui.subVectors(n,i),o=(u-a)/(u-a+(p-f)),e.copy(i).addScaledVector(ui,o);const M=1/(y+m+d);return r=m*M,o=d*M,e.copy(s).addScaledVector(re,r).addScaledVector(oe,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const pi={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Jt={h:0,s:0,l:0},Re={h:0,s:0,l:0};function ws(l,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?l+(t-l)*6*e:e<1/2?t:e<2/3?l+(t-l)*6*(2/3-e):l}class Ne{constructor(t,e,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,s)}set(t,e,s){if(e===void 0&&s===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,s);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=yt){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,xt.colorSpaceToWorking(this,e),this}setRGB(t,e,s,i=xt.workingColorSpace){return this.r=t,this.g=e,this.b=s,xt.colorSpaceToWorking(this,i),this}setHSL(t,e,s,i=xt.workingColorSpace){if(t=Hi(t,1),e=N(e,0,1),s=N(s,0,1),e===0)this.r=this.g=this.b=s;else{const n=s<=.5?s*(1+e):s+e-s*e,r=2*s-n;this.r=ws(r,n,t+1/3),this.g=ws(r,n,t),this.b=ws(r,n,t-1/3)}return xt.colorSpaceToWorking(this,i),this}setStyle(t,e=yt){function s(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let n;const r=i[1],o=i[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,e);if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,e);break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=i[1],r=n.length;if(r===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=yt){const s=pi[t.toLowerCase()];return s!==void 0?this.setHex(s,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=vt(t.r),this.g=vt(t.g),this.b=vt(t.b),this}copyLinearToSRGB(t){return this.r=jt(t.r),this.g=jt(t.g),this.b=jt(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=yt){return xt.workingToColorSpace(ot.copy(this),t),Math.round(N(ot.r*255,0,255))*65536+Math.round(N(ot.g*255,0,255))*256+Math.round(N(ot.b*255,0,255))}getHexString(t=yt){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=xt.workingColorSpace){xt.workingToColorSpace(ot.copy(this),e);const s=ot.r,i=ot.g,n=ot.b,r=Math.max(s,i,n),o=Math.min(s,i,n);let h,c;const a=(o+r)/2;if(o===r)h=0,c=0;else{const u=r-o;switch(c=a<=.5?u/(r+o):u/(2-r-o),r){case s:h=(i-n)/u+(i<n?6:0);break;case i:h=(n-s)/u+2;break;case n:h=(s-i)/u+4;break}h/=6}return t.h=h,t.s=c,t.l=a,t}getRGB(t,e=xt.workingColorSpace){return xt.workingToColorSpace(ot.copy(this),e),t.r=ot.r,t.g=ot.g,t.b=ot.b,t}getStyle(t=yt){xt.workingToColorSpace(ot.copy(this),t);const e=ot.r,s=ot.g,i=ot.b;return t!==yt?`color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(t,e,s){return this.getHSL(Jt),this.setHSL(Jt.h+t,Jt.s+e,Jt.l+s)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,s){return this.r=t.r+(e.r-t.r)*s,this.g=t.g+(e.g-t.g)*s,this.b=t.b+(e.b-t.b)*s,this}lerpHSL(t,e){this.getHSL(Jt),t.getHSL(Re);const s=es(Jt.h,Re.h,e),i=es(Jt.s,Re.s,e),n=es(Jt.l,Re.l,e);return this.setHSL(s,i,n),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,s=this.g,i=this.b,n=t.elements;return this.r=n[0]*e+n[3]*s+n[6]*i,this.g=n[1]*e+n[4]*s+n[7]*i,this.b=n[2]*e+n[5]*s+n[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ot=new Ne;Ne.NAMES=pi;let cn=0;class ln extends Fe{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:cn++}),this.uuid=$t(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ne(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const s=t[e];if(s===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const s={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(t).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(t).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(t).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(t).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(t).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(s.blending=this.blending),this.side!==0&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==204&&(s.blendSrc=this.blendSrc),this.blendDst!==205&&(s.blendDst=this.blendDst),this.blendEquation!==100&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==3&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==519&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==7680&&(s.stencilFail=this.stencilFail),this.stencilZFail!==7680&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==7680&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(n){const r=[];for(const o in n){const h=n[o];delete h.metadata,r.push(h)}return r}if(e){const n=i(t.textures),r=i(t.images);n.length>0&&(s.textures=n),r.length>0&&(s.images=r)}return s}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let s=null;if(e!==null){const i=e.length;s=new Array(i);for(let n=0;n!==i;++n)s[n]=e[n].clone()}return this.clippingPlanes=s,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class di extends ln{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ne(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xe,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Q=new b,De=new T;let un=0;class H{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:un++}),this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=s,this.usage=35044,this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let i=0,n=this.itemSize;i<n;i++)this.array[t+i]=e.array[s+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,s=this.count;e<s;e++)De.fromBufferAttribute(this,e),De.applyMatrix3(t),this.setXY(e,De.x,De.y);else if(this.itemSize===3)for(let e=0,s=this.count;e<s;e++)Q.fromBufferAttribute(this,e),Q.applyMatrix3(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)Q.fromBufferAttribute(this,e),Q.applyMatrix4(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)Q.fromBufferAttribute(this,e),Q.applyNormalMatrix(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)Q.fromBufferAttribute(this,e),Q.transformDirection(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let s=this.array[t*this.itemSize+e];return this.normalized&&(s=ue(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=ht(s,this.array)),this.array[t*this.itemSize+e]=s,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=ue(e,this.array)),e}setX(t,e){return this.normalized&&(e=ht(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=ue(e,this.array)),e}setY(t,e){return this.normalized&&(e=ht(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=ue(e,this.array)),e}setZ(t,e){return this.normalized&&(e=ht(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=ue(e,this.array)),e}setW(t,e){return this.normalized&&(e=ht(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=ht(e,this.array),s=ht(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=ht(e,this.array),s=ht(s,this.array),i=ht(i,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this}setXYZW(t,e,s,i,n){return t*=this.itemSize,this.normalized&&(e=ht(e,this.array),s=ht(s,this.array),i=ht(i,this.array),n=ht(n,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==35044&&(t.usage=this.usage),t}}class pn extends H{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class dn extends H{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class R extends H{constructor(t,e,s){super(new Float32Array(t),e,s)}}let fn=0;const ft=new pt,bs=new Tt,he=new b,ct=new fe,we=new fe,st=new b;class V extends Fe{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:fn++}),this.uuid=$t(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Zi(t)?dn:pn)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const n=new St().getNormalMatrix(t);s.applyNormalMatrix(n),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ft.makeRotationFromQuaternion(t),this.applyMatrix4(ft),this}rotateX(t){return ft.makeRotationX(t),this.applyMatrix4(ft),this}rotateY(t){return ft.makeRotationY(t),this.applyMatrix4(ft),this}rotateZ(t){return ft.makeRotationZ(t),this.applyMatrix4(ft),this}translate(t,e,s){return ft.makeTranslation(t,e,s),this.applyMatrix4(ft),this}scale(t,e,s){return ft.makeScale(t,e,s),this.applyMatrix4(ft),this}lookAt(t){return bs.lookAt(t),bs.updateMatrix(),this.applyMatrix4(bs.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(he).negate(),this.translate(he.x,he.y,he.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const s=[];for(let i=0,n=t.length;i<n;i++){const r=t[i];s.push(r.x,r.y,r.z||0)}this.setAttribute("position",new R(s,3))}else{const s=Math.min(t.length,e.count);for(let i=0;i<s;i++){const n=t[i];e.setXYZ(i,n.x,n.y,n.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new fe);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new b(-1/0,-1/0,-1/0),new b(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,i=e.length;s<i;s++){const n=e[s];ct.setFromBufferAttribute(n),this.morphTargetsRelative?(st.addVectors(this.boundingBox.min,ct.min),this.boundingBox.expandByPoint(st),st.addVectors(this.boundingBox.max,ct.max),this.boundingBox.expandByPoint(st)):(this.boundingBox.expandByPoint(ct.min),this.boundingBox.expandByPoint(ct.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ii);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new b,1/0);return}if(t){const s=this.boundingSphere.center;if(ct.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const o=e[n];we.setFromBufferAttribute(o),this.morphTargetsRelative?(st.addVectors(ct.min,we.min),ct.expandByPoint(st),st.addVectors(ct.max,we.max),ct.expandByPoint(st)):(ct.expandByPoint(we.min),ct.expandByPoint(we.max))}ct.getCenter(s);let i=0;for(let n=0,r=t.count;n<r;n++)st.fromBufferAttribute(t,n),i=Math.max(i,s.distanceToSquared(st));if(e)for(let n=0,r=e.length;n<r;n++){const o=e[n],h=this.morphTargetsRelative;for(let c=0,a=o.count;c<a;c++)st.fromBufferAttribute(o,c),h&&(he.fromBufferAttribute(t,c),st.add(he)),i=Math.max(i,s.distanceToSquared(st))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.position,i=e.normal,n=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new H(new Float32Array(4*s.count),4));const r=this.getAttribute("tangent"),o=[],h=[];for(let S=0;S<s.count;S++)o[S]=new b,h[S]=new b;const c=new b,a=new b,u=new b,d=new T,p=new T,f=new T,m=new b,y=new b;function M(S,C,_){c.fromBufferAttribute(s,S),a.fromBufferAttribute(s,C),u.fromBufferAttribute(s,_),d.fromBufferAttribute(n,S),p.fromBufferAttribute(n,C),f.fromBufferAttribute(n,_),a.sub(c),u.sub(c),p.sub(d),f.sub(d);const P=1/(p.x*f.y-f.x*p.y);isFinite(P)&&(m.copy(a).multiplyScalar(f.y).addScaledVector(u,-p.y).multiplyScalar(P),y.copy(u).multiplyScalar(p.x).addScaledVector(a,-f.x).multiplyScalar(P),o[S].add(m),o[C].add(m),o[_].add(m),h[S].add(y),h[C].add(y),h[_].add(y))}let g=this.groups;g.length===0&&(g=[{start:0,count:t.count}]);for(let S=0,C=g.length;S<C;++S){const _=g[S],P=_.start,O=_.count;for(let D=P,G=P+O;D<G;D+=3)M(t.getX(D+0),t.getX(D+1),t.getX(D+2))}const w=new b,x=new b,z=new b,A=new b;function v(S){z.fromBufferAttribute(i,S),A.copy(z);const C=o[S];w.copy(C),w.sub(z.multiplyScalar(z.dot(C))).normalize(),x.crossVectors(A,C);const P=x.dot(h[S])<0?-1:1;r.setXYZW(S,w.x,w.y,w.z,P)}for(let S=0,C=g.length;S<C;++S){const _=g[S],P=_.start,O=_.count;for(let D=P,G=P+O;D<G;D+=3)v(t.getX(D+0)),v(t.getX(D+1)),v(t.getX(D+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new H(new Float32Array(e.count*3),3),this.setAttribute("normal",s);else for(let d=0,p=s.count;d<p;d++)s.setXYZ(d,0,0,0);const i=new b,n=new b,r=new b,o=new b,h=new b,c=new b,a=new b,u=new b;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),y=t.getX(d+2);i.fromBufferAttribute(e,f),n.fromBufferAttribute(e,m),r.fromBufferAttribute(e,y),a.subVectors(r,n),u.subVectors(i,n),a.cross(u),o.fromBufferAttribute(s,f),h.fromBufferAttribute(s,m),c.fromBufferAttribute(s,y),o.add(a),h.add(a),c.add(a),s.setXYZ(f,o.x,o.y,o.z),s.setXYZ(m,h.x,h.y,h.z),s.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,p=e.count;d<p;d+=3)i.fromBufferAttribute(e,d+0),n.fromBufferAttribute(e,d+1),r.fromBufferAttribute(e,d+2),a.subVectors(r,n),u.subVectors(i,n),a.cross(u),s.setXYZ(d+0,a.x,a.y,a.z),s.setXYZ(d+1,a.x,a.y,a.z),s.setXYZ(d+2,a.x,a.y,a.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)st.fromBufferAttribute(t,e),st.normalize(),t.setXYZ(e,st.x,st.y,st.z)}toNonIndexed(){function t(o,h){const c=o.array,a=o.itemSize,u=o.normalized,d=new c.constructor(h.length*a);let p=0,f=0;for(let m=0,y=h.length;m<y;m++){o.isInterleavedBufferAttribute?p=h[m]*o.data.stride+o.offset:p=h[m]*a;for(let M=0;M<a;M++)d[f++]=c[p++]}return new H(d,a,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new V,s=this.index.array,i=this.attributes;for(const o in i){const h=i[o],c=t(h,s);e.setAttribute(o,c)}const n=this.morphAttributes;for(const o in n){const h=[],c=n[o];for(let a=0,u=c.length;a<u;a++){const d=c[a],p=t(d,s);h.push(p)}e.morphAttributes[o]=h}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let o=0,h=r.length;o<h;o++){const c=r[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const h=this.parameters;for(const c in h)h[c]!==void 0&&(t[c]=h[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const h in s){const c=s[h];t.data.attributes[h]=c.toJSON(t.data)}const i={};let n=!1;for(const h in this.morphAttributes){const c=this.morphAttributes[h],a=[];for(let u=0,d=c.length;u<d;u++){const p=c[u];a.push(p.toJSON(t.data))}a.length>0&&(i[h]=a,n=!0)}n&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere=o.toJSON()),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;s!==null&&this.setIndex(s.clone());const i=t.attributes;for(const c in i){const a=i[c];this.setAttribute(c,a.clone(e))}const n=t.morphAttributes;for(const c in n){const a=[],u=n[c];for(let d=0,p=u.length;d<p;d++)a.push(u[d].clone(e));this.morphAttributes[c]=a}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let c=0,a=r.length;c<a;c++){const u=r[c];this.addGroup(u.start,u.count,u.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const h=t.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const fi=new pt,Ht=new tn,Le=new ii,mi=new b,Ve=new b,qe=new b,Je=new b,Ms=new b,Ue=new b,yi=new b,We=new b;class mn extends Tt{constructor(t=new V,e=new di){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const i=e[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=i.length;n<r;n++){const o=i[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=n}}}}getVertexPosition(t,e){const s=this.geometry,i=s.attributes.position,n=s.morphAttributes.position,r=s.morphTargetsRelative;e.fromBufferAttribute(i,t);const o=this.morphTargetInfluences;if(n&&o){Ue.set(0,0,0);for(let h=0,c=n.length;h<c;h++){const a=o[h],u=n[h];a!==0&&(Ms.fromBufferAttribute(u,t),r?Ue.addScaledVector(Ms,a):Ue.addScaledVector(Ms.sub(e),a))}e.add(Ue)}return e}raycast(t,e){const s=this.geometry,i=this.material,n=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),Le.copy(s.boundingSphere),Le.applyMatrix4(n),Ht.copy(t.ray).recast(t.near),!(Le.containsPoint(Ht.origin)===!1&&(Ht.intersectSphere(Le,mi)===null||Ht.origin.distanceToSquared(mi)>(t.far-t.near)**2))&&(fi.copy(n).invert(),Ht.copy(t.ray).applyMatrix4(fi),!(s.boundingBox!==null&&Ht.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(t,e,Ht)))}_computeIntersections(t,e,s){let i;const n=this.geometry,r=this.material,o=n.index,h=n.attributes.position,c=n.attributes.uv,a=n.attributes.uv1,u=n.attributes.normal,d=n.groups,p=n.drawRange;if(o!==null)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const y=d[f],M=r[y.materialIndex],g=Math.max(y.start,p.start),w=Math.min(o.count,Math.min(y.start+y.count,p.start+p.count));for(let x=g,z=w;x<z;x+=3){const A=o.getX(x),v=o.getX(x+1),S=o.getX(x+2);i=Ge(this,M,t,s,c,a,u,A,v,S),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=y.materialIndex,e.push(i))}}else{const f=Math.max(0,p.start),m=Math.min(o.count,p.start+p.count);for(let y=f,M=m;y<M;y+=3){const g=o.getX(y),w=o.getX(y+1),x=o.getX(y+2);i=Ge(this,r,t,s,c,a,u,g,w,x),i&&(i.faceIndex=Math.floor(y/3),e.push(i))}}else if(h!==void 0)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const y=d[f],M=r[y.materialIndex],g=Math.max(y.start,p.start),w=Math.min(h.count,Math.min(y.start+y.count,p.start+p.count));for(let x=g,z=w;x<z;x+=3){const A=x,v=x+1,S=x+2;i=Ge(this,M,t,s,c,a,u,A,v,S),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=y.materialIndex,e.push(i))}}else{const f=Math.max(0,p.start),m=Math.min(h.count,p.start+p.count);for(let y=f,M=m;y<M;y+=3){const g=y,w=y+1,x=y+2;i=Ge(this,r,t,s,c,a,u,g,w,x),i&&(i.faceIndex=Math.floor(y/3),e.push(i))}}}}function yn(l,t,e,s,i,n,r,o){let h;if(t.side===1?h=s.intersectTriangle(r,n,i,!0,o):h=s.intersectTriangle(i,n,r,t.side===0,o),h===null)return null;We.copy(o),We.applyMatrix4(l.matrixWorld);const c=e.ray.origin.distanceTo(We);return c<e.near||c>e.far?null:{distance:c,point:We.clone(),object:l}}function Ge(l,t,e,s,i,n,r,o,h,c){l.getVertexPosition(o,Ve),l.getVertexPosition(h,qe),l.getVertexPosition(c,Je);const a=yn(l,t,e,s,Ve,qe,Je,yi);if(a){const u=new b;dt.getBarycoord(yi,Ve,qe,Je,u),i&&(a.uv=dt.getInterpolatedAttribute(i,o,h,c,u,new T)),n&&(a.uv1=dt.getInterpolatedAttribute(n,o,h,c,u,new T)),r&&(a.normal=dt.getInterpolatedAttribute(r,o,h,c,u,new b),a.normal.dot(s.direction)>0&&a.normal.multiplyScalar(-1));const d={a:o,b:h,c,normal:new b,materialIndex:0};dt.getNormal(Ve,qe,Je,d.normal),a.face=d,a.barycoord=u}return a}class zs extends V{constructor(t=1,e=1,s=1,i=1,n=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:s,widthSegments:i,heightSegments:n,depthSegments:r};const o=this;i=Math.floor(i),n=Math.floor(n),r=Math.floor(r);const h=[],c=[],a=[],u=[];let d=0,p=0;f("z","y","x",-1,-1,s,e,t,r,n,0),f("z","y","x",1,-1,s,e,-t,r,n,1),f("x","z","y",1,1,t,s,e,i,r,2),f("x","z","y",1,-1,t,s,-e,i,r,3),f("x","y","z",1,-1,t,e,s,i,n,4),f("x","y","z",-1,-1,t,e,-s,i,n,5),this.setIndex(h),this.setAttribute("position",new R(c,3)),this.setAttribute("normal",new R(a,3)),this.setAttribute("uv",new R(u,2));function f(m,y,M,g,w,x,z,A,v,S,C){const _=x/v,P=z/S,O=x/2,D=z/2,G=A/2,U=v+1,tt=S+1;let nt=0,Mt=0;const $=new b;for(let K=0;K<tt;K++){const j=K*P-D;for(let zt=0;zt<U;zt++){const mt=zt*_-O;$[m]=mt*g,$[y]=j*w,$[M]=G,c.push($.x,$.y,$.z),$[m]=0,$[y]=0,$[M]=A>0?1:-1,a.push($.x,$.y,$.z),u.push(zt/v),u.push(1-K/S),nt+=1}}for(let K=0;K<S;K++)for(let j=0;j<v;j++){const zt=d+j+U*K,mt=d+j+U*(K+1),ce=d+(j+1)+U*(K+1),Ce=d+(j+1)+U*K;h.push(zt,mt,Ce),h.push(mt,ce,Ce),Mt+=6}o.addGroup(p,Mt,C),p+=Mt,d+=nt}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new zs(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}const As=new b,xn=new b,gn=new St;class xi{constructor(t=new b(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,i){return this.normal.set(t,e,s),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const i=As.subVectors(s,e).cross(xn.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const s=t.delta(As),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/i;return n<0||n>1?null:e.copy(t.start).addScaledVector(s,n)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||gn.getNormalMatrix(t),i=this.coplanarPoint(As).applyMatrix4(t),n=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}class Ss extends V{constructor(t=1,e=1,s=4,i=8,n=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:s,radialSegments:i,heightSegments:n},e=Math.max(0,e),s=Math.max(1,Math.floor(s)),i=Math.max(3,Math.floor(i)),n=Math.max(1,Math.floor(n));const r=[],o=[],h=[],c=[],a=e/2,u=Math.PI/2*t,d=e,p=2*u+d,f=s*2+n,m=i+1,y=new b,M=new b;for(let g=0;g<=f;g++){let w=0,x=0,z=0,A=0;if(g<=s){const C=g/s,_=C*Math.PI/2;x=-a-t*Math.cos(_),z=t*Math.sin(_),A=-t*Math.cos(_),w=C*u}else if(g<=s+n){const C=(g-s)/n;x=-a+C*e,z=t,A=0,w=u+C*d}else{const C=(g-s-n)/s,_=C*Math.PI/2;x=a+t*Math.sin(_),z=t*Math.cos(_),A=t*Math.sin(_),w=u+d+C*u}const v=Math.max(0,Math.min(1,w/p));let S=0;g===0?S=.5/i:g===f&&(S=-.5/i);for(let C=0;C<=i;C++){const _=C/i,P=_*Math.PI*2,O=Math.sin(P),D=Math.cos(P);M.x=-z*D,M.y=x,M.z=z*O,o.push(M.x,M.y,M.z),y.set(-z*D,A,z*O),y.normalize(),h.push(y.x,y.y,y.z),c.push(_+S,v)}if(g>0){const C=(g-1)*m;for(let _=0;_<i;_++){const P=C+_,O=C+_+1,D=g*m+_,G=g*m+_+1;r.push(P,O,D),r.push(O,G,D)}}}this.setIndex(r),this.setAttribute("position",new R(o,3)),this.setAttribute("normal",new R(h,3)),this.setAttribute("uv",new R(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ss(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class vs extends V{constructor(t=1,e=32,s=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:s,thetaLength:i},e=Math.max(3,e);const n=[],r=[],o=[],h=[],c=new b,a=new T;r.push(0,0,0),o.push(0,0,1),h.push(.5,.5);for(let u=0,d=3;u<=e;u++,d+=3){const p=s+u/e*i;c.x=t*Math.cos(p),c.y=t*Math.sin(p),r.push(c.x,c.y,c.z),o.push(0,0,1),a.x=(r[d]/t+1)/2,a.y=(r[d+1]/t+1)/2,h.push(a.x,a.y)}for(let u=1;u<=e;u++)n.push(u,u+1,0);this.setIndex(n),this.setAttribute("position",new R(r,3)),this.setAttribute("normal",new R(o,3)),this.setAttribute("uv",new R(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new vs(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class He extends V{constructor(t=1,e=1,s=1,i=32,n=1,r=!1,o=0,h=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:s,radialSegments:i,heightSegments:n,openEnded:r,thetaStart:o,thetaLength:h};const c=this;i=Math.floor(i),n=Math.floor(n);const a=[],u=[],d=[],p=[];let f=0;const m=[],y=s/2;let M=0;g(),r===!1&&(t>0&&w(!0),e>0&&w(!1)),this.setIndex(a),this.setAttribute("position",new R(u,3)),this.setAttribute("normal",new R(d,3)),this.setAttribute("uv",new R(p,2));function g(){const x=new b,z=new b;let A=0;const v=(e-t)/s;for(let S=0;S<=n;S++){const C=[],_=S/n,P=_*(e-t)+t;for(let O=0;O<=i;O++){const D=O/i,G=D*h+o,U=Math.sin(G),tt=Math.cos(G);z.x=P*U,z.y=-_*s+y,z.z=P*tt,u.push(z.x,z.y,z.z),x.set(U,v,tt).normalize(),d.push(x.x,x.y,x.z),p.push(D,1-_),C.push(f++)}m.push(C)}for(let S=0;S<i;S++)for(let C=0;C<n;C++){const _=m[C][S],P=m[C+1][S],O=m[C+1][S+1],D=m[C][S+1];(t>0||C!==0)&&(a.push(_,P,D),A+=3),(e>0||C!==n-1)&&(a.push(P,O,D),A+=3)}c.addGroup(M,A,0),M+=A}function w(x){const z=f,A=new T,v=new b;let S=0;const C=x===!0?t:e,_=x===!0?1:-1;for(let O=1;O<=i;O++)u.push(0,y*_,0),d.push(0,_,0),p.push(.5,.5),f++;const P=f;for(let O=0;O<=i;O++){const G=O/i*h+o,U=Math.cos(G),tt=Math.sin(G);v.x=C*tt,v.y=y*_,v.z=C*U,u.push(v.x,v.y,v.z),d.push(0,_,0),A.x=U*.5+.5,A.y=tt*.5*_+.5,p.push(A.x,A.y),f++}for(let O=0;O<i;O++){const D=z+O,G=P+O;x===!0?a.push(G,G+1,D):a.push(G+1,G,D),S+=3}c.addGroup(M,S,x===!0?1:2),M+=S}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new He(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class _s extends He{constructor(t=1,e=1,s=32,i=1,n=!1,r=0,o=Math.PI*2){super(0,t,e,s,i,n,r,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:s,heightSegments:i,openEnded:n,thetaStart:r,thetaLength:o}}static fromJSON(t){return new _s(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Zt extends V{constructor(t=[],e=[],s=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:s,detail:i};const n=[],r=[];o(i),c(s),a(),this.setAttribute("position",new R(n,3)),this.setAttribute("normal",new R(n.slice(),3)),this.setAttribute("uv",new R(r,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(g){const w=new b,x=new b,z=new b;for(let A=0;A<e.length;A+=3)p(e[A+0],w),p(e[A+1],x),p(e[A+2],z),h(w,x,z,g)}function h(g,w,x,z){const A=z+1,v=[];for(let S=0;S<=A;S++){v[S]=[];const C=g.clone().lerp(x,S/A),_=w.clone().lerp(x,S/A),P=A-S;for(let O=0;O<=P;O++)O===0&&S===A?v[S][O]=C:v[S][O]=C.clone().lerp(_,O/P)}for(let S=0;S<A;S++)for(let C=0;C<2*(A-S)-1;C++){const _=Math.floor(C/2);C%2===0?(d(v[S][_+1]),d(v[S+1][_]),d(v[S][_])):(d(v[S][_+1]),d(v[S+1][_+1]),d(v[S+1][_]))}}function c(g){const w=new b;for(let x=0;x<n.length;x+=3)w.x=n[x+0],w.y=n[x+1],w.z=n[x+2],w.normalize().multiplyScalar(g),n[x+0]=w.x,n[x+1]=w.y,n[x+2]=w.z}function a(){const g=new b;for(let w=0;w<n.length;w+=3){g.x=n[w+0],g.y=n[w+1],g.z=n[w+2];const x=y(g)/2/Math.PI+.5,z=M(g)/Math.PI+.5;r.push(x,1-z)}f(),u()}function u(){for(let g=0;g<r.length;g+=6){const w=r[g+0],x=r[g+2],z=r[g+4],A=Math.max(w,x,z),v=Math.min(w,x,z);A>.9&&v<.1&&(w<.2&&(r[g+0]+=1),x<.2&&(r[g+2]+=1),z<.2&&(r[g+4]+=1))}}function d(g){n.push(g.x,g.y,g.z)}function p(g,w){const x=g*3;w.x=t[x+0],w.y=t[x+1],w.z=t[x+2]}function f(){const g=new b,w=new b,x=new b,z=new b,A=new T,v=new T,S=new T;for(let C=0,_=0;C<n.length;C+=9,_+=6){g.set(n[C+0],n[C+1],n[C+2]),w.set(n[C+3],n[C+4],n[C+5]),x.set(n[C+6],n[C+7],n[C+8]),A.set(r[_+0],r[_+1]),v.set(r[_+2],r[_+3]),S.set(r[_+4],r[_+5]),z.copy(g).add(w).add(x).divideScalar(3);const P=y(z);m(A,_+0,g,P),m(v,_+2,w,P),m(S,_+4,x,P)}}function m(g,w,x,z){z<0&&g.x===1&&(r[w]=g.x-1),x.x===0&&x.z===0&&(r[w]=z/2/Math.PI+.5)}function y(g){return Math.atan2(g.z,-g.x)}function M(g){return Math.atan2(-g.y,Math.sqrt(g.x*g.x+g.z*g.z))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Zt(t.vertices,t.indices,t.radius,t.details)}}class Cs extends Zt{constructor(t=1,e=0){const s=(1+Math.sqrt(5))/2,i=1/s,n=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-s,0,-i,s,0,i,-s,0,i,s,-i,-s,0,-i,s,0,i,-s,0,i,s,0,-s,0,-i,s,0,-i,-s,0,i,s,0,i],r=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(n,r,t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Cs(t.radius,t.detail)}}class At{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)}getPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e}getSpacedPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,i=this.getPoint(0),n=0;e.push(0);for(let r=1;r<=t;r++)s=this.getPoint(r/t),n+=s.distanceTo(i),e.push(n),i=s;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const s=this.getLengths();let i=0;const n=s.length;let r;e?r=e:r=t*s[n-1];let o=0,h=n-1,c;for(;o<=h;)if(i=Math.floor(o+(h-o)/2),c=s[i]-r,c<0)o=i+1;else if(c>0)h=i-1;else{h=i;break}if(i=h,s[i]===r)return i/(n-1);const a=s[i],d=s[i+1]-a,p=(r-a)/d;return(i+p)/(n-1)}getTangent(t,e){let i=t-1e-4,n=t+1e-4;i<0&&(i=0),n>1&&(n=1);const r=this.getPoint(i),o=this.getPoint(n),h=e||(r.isVector2?new T:new b);return h.copy(o).sub(r).normalize(),h}getTangentAt(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)}computeFrenetFrames(t,e=!1){const s=new b,i=[],n=[],r=[],o=new b,h=new pt;for(let p=0;p<=t;p++){const f=p/t;i[p]=this.getTangentAt(f,new b)}n[0]=new b,r[0]=new b;let c=Number.MAX_VALUE;const a=Math.abs(i[0].x),u=Math.abs(i[0].y),d=Math.abs(i[0].z);a<=c&&(c=a,s.set(1,0,0)),u<=c&&(c=u,s.set(0,1,0)),d<=c&&s.set(0,0,1),o.crossVectors(i[0],s).normalize(),n[0].crossVectors(i[0],o),r[0].crossVectors(i[0],n[0]);for(let p=1;p<=t;p++){if(n[p]=n[p-1].clone(),r[p]=r[p-1].clone(),o.crossVectors(i[p-1],i[p]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(N(i[p-1].dot(i[p]),-1,1));n[p].applyMatrix4(h.makeRotationAxis(o,f))}r[p].crossVectors(i[p],n[p])}if(e===!0){let p=Math.acos(N(n[0].dot(n[t]),-1,1));p/=t,i[0].dot(o.crossVectors(n[0],n[t]))>0&&(p=-p);for(let f=1;f<=t;f++)n[f].applyMatrix4(h.makeRotationAxis(i[f],p*f)),r[f].crossVectors(i[f],n[f])}return{tangents:i,normals:n,binormals:r}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Fs extends At{constructor(t=0,e=0,s=1,i=1,n=0,r=Math.PI*2,o=!1,h=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=s,this.yRadius=i,this.aStartAngle=n,this.aEndAngle=r,this.aClockwise=o,this.aRotation=h}getPoint(t,e=new T){const s=e,i=Math.PI*2;let n=this.aEndAngle-this.aStartAngle;const r=Math.abs(n)<Number.EPSILON;for(;n<0;)n+=i;for(;n>i;)n-=i;n<Number.EPSILON&&(r?n=0:n=i),this.aClockwise===!0&&!r&&(n===i?n=-i:n=n-i);const o=this.aStartAngle+t*n;let h=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const a=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=h-this.aX,p=c-this.aY;h=d*a-p*u+this.aX,c=d*u+p*a+this.aY}return s.set(h,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class wn extends Fs{constructor(t,e,s,i,n,r){super(t,e,s,s,i,n,r),this.isArcCurve=!0,this.type="ArcCurve"}}function Ts(){let l=0,t=0,e=0,s=0;function i(n,r,o,h){l=n,t=o,e=-3*n+3*r-2*o-h,s=2*n-2*r+o+h}return{initCatmullRom:function(n,r,o,h,c){i(r,o,c*(o-n),c*(h-r))},initNonuniformCatmullRom:function(n,r,o,h,c,a,u){let d=(r-n)/c-(o-n)/(c+a)+(o-r)/a,p=(o-r)/a-(h-r)/(a+u)+(h-o)/u;d*=a,p*=a,i(r,o,d,p)},calc:function(n){const r=n*n,o=r*n;return l+t*n+e*r+s*o}}}const Ze=new b,Bs=new Ts,Es=new Ts,Ps=new Ts;class gi extends At{constructor(t=[],e=!1,s="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=s,this.tension=i}getPoint(t,e=new b){const s=e,i=this.points,n=i.length,r=(n-(this.closed?0:1))*t;let o=Math.floor(r),h=r-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/n)+1)*n:h===0&&o===n-1&&(o=n-2,h=1);let c,a;this.closed||o>0?c=i[(o-1)%n]:(Ze.subVectors(i[0],i[1]).add(i[0]),c=Ze);const u=i[o%n],d=i[(o+1)%n];if(this.closed||o+2<n?a=i[(o+2)%n]:(Ze.subVectors(i[n-1],i[n-2]).add(i[n-1]),a=Ze),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(c.distanceToSquared(u),p),m=Math.pow(u.distanceToSquared(d),p),y=Math.pow(d.distanceToSquared(a),p);m<1e-4&&(m=1),f<1e-4&&(f=m),y<1e-4&&(y=m),Bs.initNonuniformCatmullRom(c.x,u.x,d.x,a.x,f,m,y),Es.initNonuniformCatmullRom(c.y,u.y,d.y,a.y,f,m,y),Ps.initNonuniformCatmullRom(c.z,u.z,d.z,a.z,f,m,y)}else this.curveType==="catmullrom"&&(Bs.initCatmullRom(c.x,u.x,d.x,a.x,this.tension),Es.initCatmullRom(c.y,u.y,d.y,a.y,this.tension),Ps.initCatmullRom(c.z,u.z,d.z,a.z,this.tension));return s.set(Bs.calc(h),Es.calc(h),Ps.calc(h)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(new b().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function wi(l,t,e,s,i){const n=(s-t)*.5,r=(i-e)*.5,o=l*l,h=l*o;return(2*e-2*s+n+r)*h+(-3*e+3*s-2*n-r)*o+n*l+e}function bn(l,t){const e=1-l;return e*e*t}function Mn(l,t){return 2*(1-l)*l*t}function zn(l,t){return l*l*t}function be(l,t,e,s){return bn(l,t)+Mn(l,e)+zn(l,s)}function An(l,t){const e=1-l;return e*e*e*t}function Sn(l,t){const e=1-l;return 3*e*e*l*t}function vn(l,t){return 3*(1-l)*l*l*t}function _n(l,t){return l*l*l*t}function Me(l,t,e,s,i){return An(l,t)+Sn(l,e)+vn(l,s)+_n(l,i)}class bi extends At{constructor(t=new T,e=new T,s=new T,i=new T){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=s,this.v3=i}getPoint(t,e=new T){const s=e,i=this.v0,n=this.v1,r=this.v2,o=this.v3;return s.set(Me(t,i.x,n.x,r.x,o.x),Me(t,i.y,n.y,r.y,o.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Cn extends At{constructor(t=new b,e=new b,s=new b,i=new b){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=s,this.v3=i}getPoint(t,e=new b){const s=e,i=this.v0,n=this.v1,r=this.v2,o=this.v3;return s.set(Me(t,i.x,n.x,r.x,o.x),Me(t,i.y,n.y,r.y,o.y),Me(t,i.z,n.z,r.z,o.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Mi extends At{constructor(t=new T,e=new T){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new T){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new T){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Fn extends At{constructor(t=new b,e=new b){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new b){const s=e;return t===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(t).add(this.v1)),s}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new b){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class zi extends At{constructor(t=new T,e=new T,s=new T){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new T){const s=e,i=this.v0,n=this.v1,r=this.v2;return s.set(be(t,i.x,n.x,r.x),be(t,i.y,n.y,r.y)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Ai extends At{constructor(t=new b,e=new b,s=new b){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=s}getPoint(t,e=new b){const s=e,i=this.v0,n=this.v1,r=this.v2;return s.set(be(t,i.x,n.x,r.x),be(t,i.y,n.y,r.y),be(t,i.z,n.z,r.z)),s}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Si extends At{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new T){const s=e,i=this.points,n=(i.length-1)*t,r=Math.floor(n),o=n-r,h=i[r===0?r:r-1],c=i[r],a=i[r>i.length-2?i.length-1:r+1],u=i[r>i.length-3?i.length-1:r+2];return s.set(wi(o,h.x,c.x,a.x,u.x),wi(o,h.y,c.y,a.y,u.y)),s}copy(t){super.copy(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,s=this.points.length;e<s;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,s=t.points.length;e<s;e++){const i=t.points[e];this.points.push(new T().fromArray(i))}return this}}var Xe=Object.freeze({__proto__:null,ArcCurve:wn,CatmullRomCurve3:gi,CubicBezierCurve:bi,CubicBezierCurve3:Cn,EllipseCurve:Fs,LineCurve:Mi,LineCurve3:Fn,QuadraticBezierCurve:zi,QuadraticBezierCurve3:Ai,SplineCurve:Si});class Tn extends At{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const s=t.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Xe[s](e,t))}return this}getPoint(t,e){const s=t*this.getLength(),i=this.getCurveLengths();let n=0;for(;n<i.length;){if(i[n]>=s){const r=i[n]-s,o=this.curves[n],h=o.getLength(),c=h===0?0:1-r/h;return o.getPointAt(c,e)}n++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let s=0,i=this.curves.length;s<i;s++)e+=this.curves[s].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let s;for(let i=0,n=this.curves;i<n.length;i++){const r=n[i],o=r.isEllipseCurve?t*2:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?t*r.points.length:t,h=r.getPoints(o);for(let c=0;c<h.length;c++){const a=h[c];s&&s.equals(a)||(e.push(a),s=a)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,s=this.curves.length;e<s;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const i=t.curves[e];this.curves.push(new Xe[i.type]().fromJSON(i))}return this}}class vi extends Tn{constructor(t){super(),this.type="Path",this.currentPoint=new T,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,s=t.length;e<s;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const s=new Mi(this.currentPoint.clone(),new T(t,e));return this.curves.push(s),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,s,i){const n=new zi(this.currentPoint.clone(),new T(t,e),new T(s,i));return this.curves.push(n),this.currentPoint.set(s,i),this}bezierCurveTo(t,e,s,i,n,r){const o=new bi(this.currentPoint.clone(),new T(t,e),new T(s,i),new T(n,r));return this.curves.push(o),this.currentPoint.set(n,r),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),s=new Si(e);return this.curves.push(s),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,s,i,n,r){const o=this.currentPoint.x,h=this.currentPoint.y;return this.absarc(t+o,e+h,s,i,n,r),this}absarc(t,e,s,i,n,r){return this.absellipse(t,e,s,s,i,n,r),this}ellipse(t,e,s,i,n,r,o,h){const c=this.currentPoint.x,a=this.currentPoint.y;return this.absellipse(t+c,e+a,s,i,n,r,o,h),this}absellipse(t,e,s,i,n,r,o,h){const c=new Fs(t,e,s,i,n,r,o,h);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const a=c.getPoint(1);return this.currentPoint.copy(a),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class _i extends vi{constructor(t){super(t),this.uuid=$t(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let s=0,i=this.holes.length;s<i;s++)e[s]=this.holes[s].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,s=this.holes.length;e<s;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,s=t.holes.length;e<s;e++){const i=t.holes[e];this.holes.push(new vi().fromJSON(i))}return this}}function Bn(l,t,e=2){const s=t&&t.length,i=s?t[0]*e:l.length;let n=Ci(l,0,i,e,!0);const r=[];if(!n||n.next===n.prev)return r;let o,h,c;if(s&&(n=On(l,t,n,e)),l.length>80*e){o=1/0,h=1/0;let a=-1/0,u=-1/0;for(let d=e;d<i;d+=e){const p=l[d],f=l[d+1];p<o&&(o=p),f<h&&(h=f),p>a&&(a=p),f>u&&(u=f)}c=Math.max(a-o,u-h),c=c!==0?32767/c:0}return ze(n,r,e,o,h,c,0),r}function Ci(l,t,e,s,i){let n;if(i===Hn(l,t,e,s)>0)for(let r=t;r<e;r+=s)n=Ei(r/s|0,l[r],l[r+1],n);else for(let r=e-s;r>=t;r-=s)n=Ei(r/s|0,l[r],l[r+1],n);return n&&ae(n,n.next)&&(ve(n),n=n.next),n}function Xt(l,t){if(!l)return l;t||(t=l);let e=l,s;do if(s=!1,!e.steiner&&(ae(e,e.next)||X(e.prev,e,e.next)===0)){if(ve(e),e=t=e.prev,e===e.next)break;s=!0}else e=e.next;while(s||e!==t);return t}function ze(l,t,e,s,i,n,r){if(!l)return;!r&&n&&Vn(l,s,i,n);let o=l;for(;l.prev!==l.next;){const h=l.prev,c=l.next;if(n?Pn(l,s,i,n):En(l)){t.push(h.i,l.i,c.i),ve(l),l=c.next,o=c.next;continue}if(l=c,l===o){r?r===1?(l=kn(Xt(l),t),ze(l,t,e,s,i,n,2)):r===2&&In(l,t,e,s,i,n):ze(Xt(l),t,e,s,i,n,1);break}}}function En(l){const t=l.prev,e=l,s=l.next;if(X(t,e,s)>=0)return!1;const i=t.x,n=e.x,r=s.x,o=t.y,h=e.y,c=s.y,a=Math.min(i,n,r),u=Math.min(o,h,c),d=Math.max(i,n,r),p=Math.max(o,h,c);let f=s.next;for(;f!==t;){if(f.x>=a&&f.x<=d&&f.y>=u&&f.y<=p&&Ae(i,o,n,h,r,c,f.x,f.y)&&X(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function Pn(l,t,e,s){const i=l.prev,n=l,r=l.next;if(X(i,n,r)>=0)return!1;const o=i.x,h=n.x,c=r.x,a=i.y,u=n.y,d=r.y,p=Math.min(o,h,c),f=Math.min(a,u,d),m=Math.max(o,h,c),y=Math.max(a,u,d),M=ks(p,f,t,e,s),g=ks(m,y,t,e,s);let w=l.prevZ,x=l.nextZ;for(;w&&w.z>=M&&x&&x.z<=g;){if(w.x>=p&&w.x<=m&&w.y>=f&&w.y<=y&&w!==i&&w!==r&&Ae(o,a,h,u,c,d,w.x,w.y)&&X(w.prev,w,w.next)>=0||(w=w.prevZ,x.x>=p&&x.x<=m&&x.y>=f&&x.y<=y&&x!==i&&x!==r&&Ae(o,a,h,u,c,d,x.x,x.y)&&X(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;w&&w.z>=M;){if(w.x>=p&&w.x<=m&&w.y>=f&&w.y<=y&&w!==i&&w!==r&&Ae(o,a,h,u,c,d,w.x,w.y)&&X(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;x&&x.z<=g;){if(x.x>=p&&x.x<=m&&x.y>=f&&x.y<=y&&x!==i&&x!==r&&Ae(o,a,h,u,c,d,x.x,x.y)&&X(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function kn(l,t){let e=l;do{const s=e.prev,i=e.next.next;!ae(s,i)&&Ti(s,e,e.next,i)&&Se(s,i)&&Se(i,s)&&(t.push(s.i,e.i,i.i),ve(e),ve(e.next),e=l=i),e=e.next}while(e!==l);return Xt(e)}function In(l,t,e,s,i,n){let r=l;do{let o=r.next.next;for(;o!==r.prev;){if(r.i!==o.i&&Un(r,o)){let h=Bi(r,o);r=Xt(r,r.next),h=Xt(h,h.next),ze(r,t,e,s,i,n,0),ze(h,t,e,s,i,n,0);return}o=o.next}r=r.next}while(r!==l)}function On(l,t,e,s){const i=[];for(let n=0,r=t.length;n<r;n++){const o=t[n]*s,h=n<r-1?t[n+1]*s:l.length,c=Ci(l,o,h,s,!1);c===c.next&&(c.steiner=!0),i.push(Jn(c))}i.sort(Rn);for(let n=0;n<i.length;n++)e=Nn(i[n],e);return e}function Rn(l,t){let e=l.x-t.x;if(e===0&&(e=l.y-t.y,e===0)){const s=(l.next.y-l.y)/(l.next.x-l.x),i=(t.next.y-t.y)/(t.next.x-t.x);e=s-i}return e}function Nn(l,t){const e=Dn(l,t);if(!e)return t;const s=Bi(e,l);return Xt(s,s.next),Xt(e,e.next)}function Dn(l,t){let e=t;const s=l.x,i=l.y;let n=-1/0,r;if(ae(l,e))return e;do{if(ae(l,e.next))return e.next;if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const u=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(u<=s&&u>n&&(n=u,r=e.x<e.next.x?e:e.next,u===s))return r}e=e.next}while(e!==t);if(!r)return null;const o=r,h=r.x,c=r.y;let a=1/0;e=r;do{if(s>=e.x&&e.x>=h&&s!==e.x&&Fi(i<c?s:n,i,h,c,i<c?n:s,i,e.x,e.y)){const u=Math.abs(i-e.y)/(s-e.x);Se(e,l)&&(u<a||u===a&&(e.x>r.x||e.x===r.x&&Ln(r,e)))&&(r=e,a=u)}e=e.next}while(e!==o);return r}function Ln(l,t){return X(l.prev,l,t.prev)<0&&X(t.next,l,l.next)<0}function Vn(l,t,e,s){let i=l;do i.z===0&&(i.z=ks(i.x,i.y,t,e,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==l);i.prevZ.nextZ=null,i.prevZ=null,qn(i)}function qn(l){let t,e=1;do{let s=l,i;l=null;let n=null;for(t=0;s;){t++;let r=s,o=0;for(let c=0;c<e&&(o++,r=r.nextZ,!!r);c++);let h=e;for(;o>0||h>0&&r;)o!==0&&(h===0||!r||s.z<=r.z)?(i=s,s=s.nextZ,o--):(i=r,r=r.nextZ,h--),n?n.nextZ=i:l=i,i.prevZ=n,n=i;s=r}n.nextZ=null,e*=2}while(t>1);return l}function ks(l,t,e,s,i){return l=(l-e)*i|0,t=(t-s)*i|0,l=(l|l<<8)&16711935,l=(l|l<<4)&252645135,l=(l|l<<2)&858993459,l=(l|l<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,l|t<<1}function Jn(l){let t=l,e=l;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==l);return e}function Fi(l,t,e,s,i,n,r,o){return(i-r)*(t-o)>=(l-r)*(n-o)&&(l-r)*(s-o)>=(e-r)*(t-o)&&(e-r)*(n-o)>=(i-r)*(s-o)}function Ae(l,t,e,s,i,n,r,o){return!(l===r&&t===o)&&Fi(l,t,e,s,i,n,r,o)}function Un(l,t){return l.next.i!==t.i&&l.prev.i!==t.i&&!Wn(l,t)&&(Se(l,t)&&Se(t,l)&&Gn(l,t)&&(X(l.prev,l,t.prev)||X(l,t.prev,t))||ae(l,t)&&X(l.prev,l,l.next)>0&&X(t.prev,t,t.next)>0)}function X(l,t,e){return(t.y-l.y)*(e.x-t.x)-(t.x-l.x)*(e.y-t.y)}function ae(l,t){return l.x===t.x&&l.y===t.y}function Ti(l,t,e,s){const i=$e(X(l,t,e)),n=$e(X(l,t,s)),r=$e(X(e,s,l)),o=$e(X(e,s,t));return!!(i!==n&&r!==o||i===0&&Ye(l,e,t)||n===0&&Ye(l,s,t)||r===0&&Ye(e,l,s)||o===0&&Ye(e,t,s))}function Ye(l,t,e){return t.x<=Math.max(l.x,e.x)&&t.x>=Math.min(l.x,e.x)&&t.y<=Math.max(l.y,e.y)&&t.y>=Math.min(l.y,e.y)}function $e(l){return l>0?1:l<0?-1:0}function Wn(l,t){let e=l;do{if(e.i!==l.i&&e.next.i!==l.i&&e.i!==t.i&&e.next.i!==t.i&&Ti(e,e.next,l,t))return!0;e=e.next}while(e!==l);return!1}function Se(l,t){return X(l.prev,l,l.next)<0?X(l,t,l.next)>=0&&X(l,l.prev,t)>=0:X(l,t,l.prev)<0||X(l,l.next,t)<0}function Gn(l,t){let e=l,s=!1;const i=(l.x+t.x)/2,n=(l.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&i<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(s=!s),e=e.next;while(e!==l);return s}function Bi(l,t){const e=Is(l.i,l.x,l.y),s=Is(t.i,t.x,t.y),i=l.next,n=t.prev;return l.next=t,t.prev=l,e.next=i,i.prev=e,s.next=e,e.prev=s,n.next=s,s.prev=n,s}function Ei(l,t,e,s){const i=Is(l,t,e);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function ve(l){l.next.prev=l.prev,l.prev.next=l.next,l.prevZ&&(l.prevZ.nextZ=l.nextZ),l.nextZ&&(l.nextZ.prevZ=l.prevZ)}function Is(l,t,e){return{i:l,x:t,y:e,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function Hn(l,t,e,s){let i=0;for(let n=t,r=e-s;n<e;n+=s)i+=(l[r]-l[n])*(l[n+1]+l[r+1]),r=n;return i}class Zn{static triangulate(t,e,s=2){return Bn(t,e,s)}}class Pt{static area(t){const e=t.length;let s=0;for(let i=e-1,n=0;n<e;i=n++)s+=t[i].x*t[n].y-t[n].x*t[i].y;return s*.5}static isClockWise(t){return Pt.area(t)<0}static triangulateShape(t,e){const s=[],i=[],n=[];Pi(t),ki(s,t);let r=t.length;e.forEach(Pi);for(let h=0;h<e.length;h++)i.push(r),r+=e[h].length,ki(s,e[h]);const o=Zn.triangulate(s,i);for(let h=0;h<o.length;h+=3)n.push(o.slice(h,h+3));return n}}function Pi(l){const t=l.length;t>2&&l[t-1].equals(l[0])&&l.pop()}function ki(l,t){for(let e=0;e<t.length;e++)l.push(t[e].x),l.push(t[e].y)}class Os extends V{constructor(t=new _i([new T(.5,.5),new T(-.5,.5),new T(-.5,-.5),new T(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const s=this,i=[],n=[];for(let o=0,h=t.length;o<h;o++){const c=t[o];r(c)}this.setAttribute("position",new R(i,3)),this.setAttribute("uv",new R(n,2)),this.computeVertexNormals();function r(o){const h=[],c=e.curveSegments!==void 0?e.curveSegments:12,a=e.steps!==void 0?e.steps:1,u=e.depth!==void 0?e.depth:1;let d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,p=e.bevelThickness!==void 0?e.bevelThickness:.2,f=e.bevelSize!==void 0?e.bevelSize:p-.1,m=e.bevelOffset!==void 0?e.bevelOffset:0,y=e.bevelSegments!==void 0?e.bevelSegments:3;const M=e.extrudePath,g=e.UVGenerator!==void 0?e.UVGenerator:Xn;let w,x=!1,z,A,v,S;M&&(w=M.getSpacedPoints(a),x=!0,d=!1,z=M.computeFrenetFrames(a,!1),A=new b,v=new b,S=new b),d||(y=0,p=0,f=0,m=0);const C=o.extractPoints(c);let _=C.shape;const P=C.holes;if(!Pt.isClockWise(_)){_=_.reverse();for(let F=0,B=P.length;F<B;F++){const E=P[F];Pt.isClockWise(E)&&(P[F]=E.reverse())}}function D(F){const E=10000000000000001e-36;let I=F[0];for(let k=1;k<=F.length;k++){const q=k%F.length,L=F[q],Z=L.x-I.x,Y=L.y-I.y,et=Z*Z+Y*Y,lt=Math.max(Math.abs(L.x),Math.abs(L.y),Math.abs(I.x),Math.abs(I.y)),Yt=E*lt*lt;if(et<=Yt){F.splice(q,1),k--;continue}I=L}}D(_),P.forEach(D);const G=P.length,U=_;for(let F=0;F<G;F++){const B=P[F];_=_.concat(B)}function tt(F,B,E){return B||console.error("THREE.ExtrudeGeometry: vec does not exist"),F.clone().addScaledVector(B,E)}const nt=_.length;function Mt(F,B,E){let I,k,q;const L=F.x-B.x,Z=F.y-B.y,Y=E.x-F.x,et=E.y-F.y,lt=L*L+Z*Z,Yt=L*et-Z*Y;if(Math.abs(Yt)>Number.EPSILON){const ut=Math.sqrt(lt),qi=Math.sqrt(Y*Y+et*et),Ji=B.x-Z/ut,Ui=B.y+L/ut,pr=E.x-et/qi,dr=E.y+Y/qi,Wi=((pr-Ji)*et-(dr-Ui)*Y)/(L*et-Z*Y);I=Ji+L*Wi-F.x,k=Ui+Z*Wi-F.y;const Gi=I*I+k*k;if(Gi<=2)return new T(I,k);q=Math.sqrt(Gi/2)}else{let ut=!1;L>Number.EPSILON?Y>Number.EPSILON&&(ut=!0):L<-Number.EPSILON?Y<-Number.EPSILON&&(ut=!0):Math.sign(Z)===Math.sign(et)&&(ut=!0),ut?(I=-Z,k=L,q=Math.sqrt(lt)):(I=L,k=Z,q=Math.sqrt(lt/2))}return new T(I/q,k/q)}const $=[];for(let F=0,B=U.length,E=B-1,I=F+1;F<B;F++,E++,I++)E===B&&(E=0),I===B&&(I=0),$[F]=Mt(U[F],U[E],U[I]);const K=[];let j,zt=$.concat();for(let F=0,B=G;F<B;F++){const E=P[F];j=[];for(let I=0,k=E.length,q=k-1,L=I+1;I<k;I++,q++,L++)q===k&&(q=0),L===k&&(L=0),j[I]=Mt(E[I],E[q],E[L]);K.push(j),zt=zt.concat(j)}let mt;if(y===0)mt=Pt.triangulateShape(U,P);else{const F=[],B=[];for(let E=0;E<y;E++){const I=E/y,k=p*Math.cos(I*Math.PI/2),q=f*Math.sin(I*Math.PI/2)+m;for(let L=0,Z=U.length;L<Z;L++){const Y=tt(U[L],$[L],q);kt(Y.x,Y.y,-k),I===0&&F.push(Y)}for(let L=0,Z=G;L<Z;L++){const Y=P[L];j=K[L];const et=[];for(let lt=0,Yt=Y.length;lt<Yt;lt++){const ut=tt(Y[lt],j[lt],q);kt(ut.x,ut.y,-k),I===0&&et.push(ut)}I===0&&B.push(et)}}mt=Pt.triangulateShape(F,B)}const ce=mt.length,Ce=f+m;for(let F=0;F<nt;F++){const B=d?tt(_[F],zt[F],Ce):_[F];x?(v.copy(z.normals[0]).multiplyScalar(B.x),A.copy(z.binormals[0]).multiplyScalar(B.y),S.copy(w[0]).add(v).add(A),kt(S.x,S.y,S.z)):kt(B.x,B.y,0)}for(let F=1;F<=a;F++)for(let B=0;B<nt;B++){const E=d?tt(_[B],zt[B],Ce):_[B];x?(v.copy(z.normals[F]).multiplyScalar(E.x),A.copy(z.binormals[F]).multiplyScalar(E.y),S.copy(w[F]).add(v).add(A),kt(S.x,S.y,S.z)):kt(E.x,E.y,u/a*F)}for(let F=y-1;F>=0;F--){const B=F/y,E=p*Math.cos(B*Math.PI/2),I=f*Math.sin(B*Math.PI/2)+m;for(let k=0,q=U.length;k<q;k++){const L=tt(U[k],$[k],I);kt(L.x,L.y,u+E)}for(let k=0,q=P.length;k<q;k++){const L=P[k];j=K[k];for(let Z=0,Y=L.length;Z<Y;Z++){const et=tt(L[Z],j[Z],I);x?kt(et.x,et.y+w[a-1].y,w[a-1].x+E):kt(et.x,et.y,u+E)}}}cr(),lr();function cr(){const F=i.length/3;if(d){let B=0,E=nt*B;for(let I=0;I<ce;I++){const k=mt[I];Ke(k[2]+E,k[1]+E,k[0]+E)}B=a+y*2,E=nt*B;for(let I=0;I<ce;I++){const k=mt[I];Ke(k[0]+E,k[1]+E,k[2]+E)}}else{for(let B=0;B<ce;B++){const E=mt[B];Ke(E[2],E[1],E[0])}for(let B=0;B<ce;B++){const E=mt[B];Ke(E[0]+nt*a,E[1]+nt*a,E[2]+nt*a)}}s.addGroup(F,i.length/3-F,0)}function lr(){const F=i.length/3;let B=0;Vi(U,B),B+=U.length;for(let E=0,I=P.length;E<I;E++){const k=P[E];Vi(k,B),B+=k.length}s.addGroup(F,i.length/3-F,1)}function Vi(F,B){let E=F.length;for(;--E>=0;){const I=E;let k=E-1;k<0&&(k=F.length-1);for(let q=0,L=a+y*2;q<L;q++){const Z=nt*q,Y=nt*(q+1),et=B+I+Z,lt=B+k+Z,Yt=B+k+Y,ut=B+I+Y;ur(et,lt,Yt,ut)}}}function kt(F,B,E){h.push(F),h.push(B),h.push(E)}function Ke(F,B,E){It(F),It(B),It(E);const I=i.length/3,k=g.generateTopUV(s,i,I-3,I-2,I-1);Ot(k[0]),Ot(k[1]),Ot(k[2])}function ur(F,B,E,I){It(F),It(B),It(I),It(B),It(E),It(I);const k=i.length/3,q=g.generateSideWallUV(s,i,k-6,k-3,k-2,k-1);Ot(q[0]),Ot(q[1]),Ot(q[3]),Ot(q[1]),Ot(q[2]),Ot(q[3])}function It(F){i.push(h[F*3+0]),i.push(h[F*3+1]),i.push(h[F*3+2])}function Ot(F){n.push(F.x),n.push(F.y)}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,s=this.parameters.options;return Yn(e,s,t)}static fromJSON(t,e){const s=[];for(let n=0,r=t.shapes.length;n<r;n++){const o=e[t.shapes[n]];s.push(o)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new Xe[i.type]().fromJSON(i)),new Os(s,t.options)}}const Xn={generateTopUV:function(l,t,e,s,i){const n=t[e*3],r=t[e*3+1],o=t[s*3],h=t[s*3+1],c=t[i*3],a=t[i*3+1];return[new T(n,r),new T(o,h),new T(c,a)]},generateSideWallUV:function(l,t,e,s,i,n){const r=t[e*3],o=t[e*3+1],h=t[e*3+2],c=t[s*3],a=t[s*3+1],u=t[s*3+2],d=t[i*3],p=t[i*3+1],f=t[i*3+2],m=t[n*3],y=t[n*3+1],M=t[n*3+2];return Math.abs(o-a)<Math.abs(r-c)?[new T(r,1-h),new T(c,1-u),new T(d,1-f),new T(m,1-M)]:[new T(o,1-h),new T(a,1-u),new T(p,1-f),new T(y,1-M)]}};function Yn(l,t,e){if(e.shapes=[],Array.isArray(l))for(let s=0,i=l.length;s<i;s++){const n=l[s];e.shapes.push(n.uuid)}else e.shapes.push(l.uuid);return e.options=Object.assign({},t),t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Rs extends Zt{constructor(t=1,e=0){const s=(1+Math.sqrt(5))/2,i=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],n=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,n,t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Rs(t.radius,t.detail)}}class Ns extends V{constructor(t=[new T(0,-.5),new T(.5,0),new T(0,.5)],e=12,s=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:s,phiLength:i},e=Math.floor(e),i=N(i,0,Math.PI*2);const n=[],r=[],o=[],h=[],c=[],a=1/e,u=new b,d=new T,p=new b,f=new b,m=new b;let y=0,M=0;for(let g=0;g<=t.length-1;g++)switch(g){case 0:y=t[g+1].x-t[g].x,M=t[g+1].y-t[g].y,p.x=M*1,p.y=-y,p.z=M*0,m.copy(p),p.normalize(),h.push(p.x,p.y,p.z);break;case t.length-1:h.push(m.x,m.y,m.z);break;default:y=t[g+1].x-t[g].x,M=t[g+1].y-t[g].y,p.x=M*1,p.y=-y,p.z=M*0,f.copy(p),p.x+=m.x,p.y+=m.y,p.z+=m.z,p.normalize(),h.push(p.x,p.y,p.z),m.copy(f)}for(let g=0;g<=e;g++){const w=s+g*a*i,x=Math.sin(w),z=Math.cos(w);for(let A=0;A<=t.length-1;A++){u.x=t[A].x*x,u.y=t[A].y,u.z=t[A].x*z,r.push(u.x,u.y,u.z),d.x=g/e,d.y=A/(t.length-1),o.push(d.x,d.y);const v=h[3*A+0]*x,S=h[3*A+1],C=h[3*A+0]*z;c.push(v,S,C)}}for(let g=0;g<e;g++)for(let w=0;w<t.length-1;w++){const x=w+g*t.length,z=x,A=x+t.length,v=x+t.length+1,S=x+1;n.push(z,A,S),n.push(v,S,A)}this.setIndex(n),this.setAttribute("position",new R(r,3)),this.setAttribute("uv",new R(o,2)),this.setAttribute("normal",new R(c,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ns(t.points,t.segments,t.phiStart,t.phiLength)}}class Ds extends Zt{constructor(t=1,e=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,i,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ds(t.radius,t.detail)}}class Ls extends V{constructor(t=1,e=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:s,heightSegments:i};const n=t/2,r=e/2,o=Math.floor(s),h=Math.floor(i),c=o+1,a=h+1,u=t/o,d=e/h,p=[],f=[],m=[],y=[];for(let M=0;M<a;M++){const g=M*d-r;for(let w=0;w<c;w++){const x=w*u-n;f.push(x,-g,0),m.push(0,0,1),y.push(w/o),y.push(1-M/h)}}for(let M=0;M<h;M++)for(let g=0;g<o;g++){const w=g+c*M,x=g+c*(M+1),z=g+1+c*(M+1),A=g+1+c*M;p.push(w,x,A),p.push(x,z,A)}this.setIndex(p),this.setAttribute("position",new R(f,3)),this.setAttribute("normal",new R(m,3)),this.setAttribute("uv",new R(y,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ls(t.width,t.height,t.widthSegments,t.heightSegments)}}class Vs extends V{constructor(t=.5,e=1,s=32,i=1,n=0,r=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:s,phiSegments:i,thetaStart:n,thetaLength:r},s=Math.max(3,s),i=Math.max(1,i);const o=[],h=[],c=[],a=[];let u=t;const d=(e-t)/i,p=new b,f=new T;for(let m=0;m<=i;m++){for(let y=0;y<=s;y++){const M=n+y/s*r;p.x=u*Math.cos(M),p.y=u*Math.sin(M),h.push(p.x,p.y,p.z),c.push(0,0,1),f.x=(p.x/e+1)/2,f.y=(p.y/e+1)/2,a.push(f.x,f.y)}u+=d}for(let m=0;m<i;m++){const y=m*(s+1);for(let M=0;M<s;M++){const g=M+y,w=g,x=g+s+1,z=g+s+2,A=g+1;o.push(w,x,A),o.push(x,z,A)}}this.setIndex(o),this.setAttribute("position",new R(h,3)),this.setAttribute("normal",new R(c,3)),this.setAttribute("uv",new R(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Vs(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class qs extends V{constructor(t=new _i([new T(0,.5),new T(-.5,-.5),new T(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const s=[],i=[],n=[],r=[];let o=0,h=0;if(Array.isArray(t)===!1)c(t);else for(let a=0;a<t.length;a++)c(t[a]),this.addGroup(o,h,a),o+=h,h=0;this.setIndex(s),this.setAttribute("position",new R(i,3)),this.setAttribute("normal",new R(n,3)),this.setAttribute("uv",new R(r,2));function c(a){const u=i.length/3,d=a.extractPoints(e);let p=d.shape;const f=d.holes;Pt.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,M=f.length;y<M;y++){const g=f[y];Pt.isClockWise(g)===!0&&(f[y]=g.reverse())}const m=Pt.triangulateShape(p,f);for(let y=0,M=f.length;y<M;y++){const g=f[y];p=p.concat(g)}for(let y=0,M=p.length;y<M;y++){const g=p[y];i.push(g.x,g.y,0),n.push(0,0,1),r.push(g.x,g.y)}for(let y=0,M=m.length;y<M;y++){const g=m[y],w=g[0]+u,x=g[1]+u,z=g[2]+u;s.push(w,x,z),h+=3}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return $n(e,t)}static fromJSON(t,e){const s=[];for(let i=0,n=t.shapes.length;i<n;i++){const r=e[t.shapes[i]];s.push(r)}return new qs(s,t.curveSegments)}}function $n(l,t){if(t.shapes=[],Array.isArray(l))for(let e=0,s=l.length;e<s;e++){const i=l[e];t.shapes.push(i.uuid)}else t.shapes.push(l.uuid);return t}class Js extends V{constructor(t=1,e=32,s=16,i=0,n=Math.PI*2,r=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:s,phiStart:i,phiLength:n,thetaStart:r,thetaLength:o},e=Math.max(3,Math.floor(e)),s=Math.max(2,Math.floor(s));const h=Math.min(r+o,Math.PI);let c=0;const a=[],u=new b,d=new b,p=[],f=[],m=[],y=[];for(let M=0;M<=s;M++){const g=[],w=M/s;let x=0;M===0&&r===0?x=.5/e:M===s&&h===Math.PI&&(x=-.5/e);for(let z=0;z<=e;z++){const A=z/e;u.x=-t*Math.cos(i+A*n)*Math.sin(r+w*o),u.y=t*Math.cos(r+w*o),u.z=t*Math.sin(i+A*n)*Math.sin(r+w*o),f.push(u.x,u.y,u.z),d.copy(u).normalize(),m.push(d.x,d.y,d.z),y.push(A+x,1-w),g.push(c++)}a.push(g)}for(let M=0;M<s;M++)for(let g=0;g<e;g++){const w=a[M][g+1],x=a[M][g],z=a[M+1][g],A=a[M+1][g+1];(M!==0||r>0)&&p.push(w,x,A),(M!==s-1||h<Math.PI)&&p.push(x,z,A)}this.setIndex(p),this.setAttribute("position",new R(f,3)),this.setAttribute("normal",new R(m,3)),this.setAttribute("uv",new R(y,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Js(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Us extends Zt{constructor(t=1,e=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,i,t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Us(t.radius,t.detail)}}class Ws extends V{constructor(t=1,e=.4,s=12,i=48,n=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:s,tubularSegments:i,arc:n},s=Math.floor(s),i=Math.floor(i);const r=[],o=[],h=[],c=[],a=new b,u=new b,d=new b;for(let p=0;p<=s;p++)for(let f=0;f<=i;f++){const m=f/i*n,y=p/s*Math.PI*2;u.x=(t+e*Math.cos(y))*Math.cos(m),u.y=(t+e*Math.cos(y))*Math.sin(m),u.z=e*Math.sin(y),o.push(u.x,u.y,u.z),a.x=t*Math.cos(m),a.y=t*Math.sin(m),d.subVectors(u,a).normalize(),h.push(d.x,d.y,d.z),c.push(f/i),c.push(p/s)}for(let p=1;p<=s;p++)for(let f=1;f<=i;f++){const m=(i+1)*p+f-1,y=(i+1)*(p-1)+f-1,M=(i+1)*(p-1)+f,g=(i+1)*p+f;r.push(m,y,g),r.push(y,M,g)}this.setIndex(r),this.setAttribute("position",new R(o,3)),this.setAttribute("normal",new R(h,3)),this.setAttribute("uv",new R(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ws(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Gs extends V{constructor(t=1,e=.4,s=64,i=8,n=2,r=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:s,radialSegments:i,p:n,q:r},s=Math.floor(s),i=Math.floor(i);const o=[],h=[],c=[],a=[],u=new b,d=new b,p=new b,f=new b,m=new b,y=new b,M=new b;for(let w=0;w<=s;++w){const x=w/s*n*Math.PI*2;g(x,n,r,t,p),g(x+.01,n,r,t,f),y.subVectors(f,p),M.addVectors(f,p),m.crossVectors(y,M),M.crossVectors(m,y),m.normalize(),M.normalize();for(let z=0;z<=i;++z){const A=z/i*Math.PI*2,v=-e*Math.cos(A),S=e*Math.sin(A);u.x=p.x+(v*M.x+S*m.x),u.y=p.y+(v*M.y+S*m.y),u.z=p.z+(v*M.z+S*m.z),h.push(u.x,u.y,u.z),d.subVectors(u,p).normalize(),c.push(d.x,d.y,d.z),a.push(w/s),a.push(z/i)}}for(let w=1;w<=s;w++)for(let x=1;x<=i;x++){const z=(i+1)*(w-1)+(x-1),A=(i+1)*w+(x-1),v=(i+1)*w+x,S=(i+1)*(w-1)+x;o.push(z,A,S),o.push(A,v,S)}this.setIndex(o),this.setAttribute("position",new R(h,3)),this.setAttribute("normal",new R(c,3)),this.setAttribute("uv",new R(a,2));function g(w,x,z,A,v){const S=Math.cos(w),C=Math.sin(w),_=z/x*w,P=Math.cos(_);v.x=A*(2+P)*.5*S,v.y=A*(2+P)*C*.5,v.z=A*Math.sin(_)*.5}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Gs(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class je extends V{constructor(t=new Ai(new b(-1,-1,0),new b(-1,1,0),new b(1,1,0)),e=64,s=1,i=8,n=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:s,radialSegments:i,closed:n};const r=t.computeFrenetFrames(e,n);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const o=new b,h=new b,c=new T;let a=new b;const u=[],d=[],p=[],f=[];m(),this.setIndex(f),this.setAttribute("position",new R(u,3)),this.setAttribute("normal",new R(d,3)),this.setAttribute("uv",new R(p,2));function m(){for(let w=0;w<e;w++)y(w);y(n===!1?e:0),g(),M()}function y(w){a=t.getPointAt(w/e,a);const x=r.normals[w],z=r.binormals[w];for(let A=0;A<=i;A++){const v=A/i*Math.PI*2,S=Math.sin(v),C=-Math.cos(v);h.x=C*x.x+S*z.x,h.y=C*x.y+S*z.y,h.z=C*x.z+S*z.z,h.normalize(),d.push(h.x,h.y,h.z),o.x=a.x+s*h.x,o.y=a.y+s*h.y,o.z=a.z+s*h.z,u.push(o.x,o.y,o.z)}}function M(){for(let w=1;w<=e;w++)for(let x=1;x<=i;x++){const z=(i+1)*(w-1)+(x-1),A=(i+1)*w+(x-1),v=(i+1)*w+x,S=(i+1)*(w-1)+x;f.push(z,A,S),f.push(A,v,S)}}function g(){for(let w=0;w<=e;w++)for(let x=0;x<=i;x++)c.x=w/e,c.y=x/i,p.push(c.x,c.y)}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new je(new Xe[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class jn extends V{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},t!==null){const e=[],s=new Set,i=new b,n=new b;if(t.index!==null){const r=t.attributes.position,o=t.index;let h=t.groups;h.length===0&&(h=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,a=h.length;c<a;++c){const u=h[c],d=u.start,p=u.count;for(let f=d,m=d+p;f<m;f+=3)for(let y=0;y<3;y++){const M=o.getX(f+y),g=o.getX(f+(y+1)%3);i.fromBufferAttribute(r,M),n.fromBufferAttribute(r,g),Ii(i,n,s)===!0&&(e.push(i.x,i.y,i.z),e.push(n.x,n.y,n.z))}}}else{const r=t.attributes.position;for(let o=0,h=r.count/3;o<h;o++)for(let c=0;c<3;c++){const a=3*o+c,u=3*o+(c+1)%3;i.fromBufferAttribute(r,a),n.fromBufferAttribute(r,u),Ii(i,n,s)===!0&&(e.push(i.x,i.y,i.z),e.push(n.x,n.y,n.z))}}this.setAttribute("position",new R(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function Ii(l,t,e){const s=`${l.x},${l.y},${l.z}-${t.x},${t.y},${t.z}`,i=`${t.x},${t.y},${t.z}-${l.x},${l.y},${l.z}`;return e.has(s)===!0||e.has(i)===!0?!1:(e.add(s),e.add(i),!0)}const Oi=new T;class Ri{constructor(t=new T(1/0,1/0),e=new T(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=Oi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Oi).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Ni=new b,Qe=new b;class Qn{constructor(t=new b,e=new b){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Ni.subVectors(t,this.start),Qe.subVectors(this.end,this.start);const s=Qe.dot(Qe);let n=Qe.dot(Ni)/s;return e&&(n=N(n,0,1)),n}closestPointToPoint(t,e,s){const i=this.closestPointToPointParameter(t,e);return this.delta(s).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Rt}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Rt),V.prototype.forEachPosition=function(l){const t=this.attributes.position;if(!t)throw new Error("Missing position attribute");const e=t.array,s=t.itemSize;for(let i=0;i<t.count;i++){const n=i*s,r=e.subarray(n,n+s);l(r,i)}},dt.prototype.toArray=function(l,t=0){return this.a.toArray(l,t),t+=3,this.b.toArray(l,t),t+=3,this.c.toArray(l,t),t+=3,t};const Di=(l,t)=>{const e=l[0].index!==null,s=new Set(Object.keys(l[0].attributes)),i=new Set(Object.keys(l[0].morphAttributes)),n={},r={},o=l[0].morphTargetsRelative,h=new V;let c=0;if(l.forEach((a,u)=>{let d=0;if(e!==(a.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let p in a.attributes){if(!s.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;n[p]===void 0&&(n[p]=[]),n[p].push(a.attributes[p]),d++}if(d!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". Make sure all geometries have the same number of attributes."),null;if(o!==a.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let p in a.morphAttributes){if(!i.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+".  .morphAttributes must be consistent throughout all geometries."),null;r[p]===void 0&&(r[p]=[]),r[p].push(a.morphAttributes[p])}h.userData.mergedUserData=h.userData.mergedUserData||[],h.userData.mergedUserData.push(a.userData);{let p;if(a.index)p=a.index.count;else if(a.attributes.position!==void 0)p=a.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+u+". The geometry must have either an index or a position attribute"),null;h.addGroup(c,p,u),c+=p}}),e){let a=0;const u=[];l.forEach(d=>{const p=d.index;for(let f=0;f<p.count;++f)u.push(p.getX(f)+a);a+=d.attributes.position.count}),h.setIndex(u)}for(let a in n){const u=Li(n[a]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" attribute."),null;h.setAttribute(a,u)}for(let a in r){const u=r[a][0].length;if(u===0)break;h.morphAttributes=h.morphAttributes||{},h.morphAttributes[a]=[];for(let d=0;d<u;++d){const p=[];for(let m=0;m<r[a].length;++m)p.push(r[a][m][d]);const f=Li(p);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" morphAttribute."),null;h.morphAttributes[a].push(f)}}return h},Li=l=>{let t,e,s,i=0;if(l.forEach(n=>{if(t===void 0&&(t=n.array.constructor),t!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(e===void 0&&(e=n.itemSize),e!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=n.normalized),s!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=n.array.length}),t&&e){const n=new t(i);let r=0;return l.forEach(o=>{n.set(o.array,r),r+=o.array.length}),new H(n,e,s)}};function Kn(l,t=1e-4){t=Math.max(t,Number.EPSILON);const e={},s=l.getIndex(),i=l.getAttribute("position"),n=s?s.count:i.count;let r=0;const o=Object.keys(l.attributes),h={},c={},a=[],u=["getX","getY","getZ","getW"];for(let m=0,y=o.length;m<y;m++){const M=o[m];h[M]=[];const g=l.morphAttributes[M];g&&(c[M]=new Array(g.length).fill(0).map(()=>[]))}const d=Math.log10(1/t),p=Math.pow(10,d);for(let m=0;m<n;m++){const y=s?s.getX(m):m;let M="";for(let g=0,w=o.length;g<w;g++){const x=o[g],z=l.getAttribute(x),A=z.itemSize;for(let v=0;v<A;v++)M+=`${~~(z[u[v]](y)*p)},`}if(M in e)a.push(e[M]);else{for(let g=0,w=o.length;g<w;g++){const x=o[g],z=l.getAttribute(x),A=l.morphAttributes[x],v=z.itemSize,S=h[x],C=c[x];for(let _=0;_<v;_++){const P=u[_];if(S.push(z[P](y)),A)for(let O=0,D=A.length;O<D;O++)C[O].push(A[O][P](y))}}e[M]=r,a.push(r),r++}}const f=l.clone();for(let m=0,y=o.length;m<y;m++){const M=o[m],g=l.getAttribute(M),w=new g.array.constructor(h[M]),x=new H(w,g.itemSize,g.normalized);if(f.setAttribute(M,x),M in c)for(let z=0;z<c[M].length;z++){const A=l.morphAttributes[M][z],v=new A.array.constructor(c[M][z]),S=new H(v,A.itemSize,A.normalized);f.morphAttributes[M][z]=S}}return f.setIndex(a),f}function tr(l){return new Worker(self.location.href,{name:l==null?void 0:l.name})}class er extends V{constructor(t){super();const e=new Float32Array(3);t.toArray(e),this.attributes.position=new H(e,3),this.index}}class sr extends V{constructor(t){super();const e=new Float32Array(t.size*3);let s=0;for(const i of t.fetch())e.set(i.pos().toArray(),s*3),s++;this.attributes.position=new H(e,3)}}class ir extends V{constructor(t,e){super();const s=new Float32Array(6);s.set(t.toArray().concat(e.toArray()),0),this.attributes.position=new H(s,3),this.setIndex([1,2])}}class nr extends V{constructor(t){super();const e=new Float32Array(t.size*2*3);let s=0;for(const i of t.fetch())for(const n of i.verts())n.pos().toArray(e,s),s+=3;this.attributes.position=new H(e,3),this.setIndex(it.createSequentialIndicesAttr(t.size*2))}}class rr extends V{constructor(t){super(),this.setFromPoints([t.a,t.b,t.c]),this.setIndex([0,1,2])}}class or extends V{constructor(t){super();const e=new Float32Array(t.size*9);let s=0;for(const i of t.fetch()){const n=i.tri();n.a.toArray(e,s),n.b.toArray(e,s+=3),n.c.toArray(e,s+=3),s+=3}this.attributes.position=new H(e,3),this.setIndex(it.createSequentialIndicesAttr(t.size*3))}}const _e=class _e extends V{constructor(e){super();J(this,"plane");J(this,"boundingBox2D");if(e.size===0){this.plane=new xi(new b(0,0,1),0),this.boundingBox2D=new Ri;return}const s=e.size,i=new Float32Array(s*9),n=new Float32Array(s*6);let r=0;for(const o of e.fetch())o.uvCoords(n,r*6),o.tri().toArray(i,r*9),r++;this.attributes.position=new H(i,3),this.attributes.uv=new H(n,2),this.setIndex(it.createSequentialIndicesAttr(s*3)),this.projectOn(e.plane),this.computeVertexNormals(),this.computeBoundingSphere()}get pos2DAttr(){return this.getAttribute(_e.ATTR_POS2D)}projectOn(e){this.plane=e;const s=this.plane.normal.clone().normalize(),i=Math.abs(s.x)>.9?new b(0,1,0):new b(1,0,0),n=new b().crossVectors(s,i).normalize(),r=new b().crossVectors(s,n).normalize(),o=this.attributes.position,h=new Float32Array(o.count*2),c=new b,a=new b;for(let u=0;u<o.count;u++)c.fromBufferAttribute(o,u),this.plane.projectPoint(c,a),h[u*2+0]=a.dot(n),h[u*2+1]=a.dot(r);this.setAttribute(_e.ATTR_POS2D,new H(h,2)),this.computeBoundingBox2D()}computeBoundingBox2D(){this.boundingBox2D=new Ri;const e=new T;for(let s=0;s<this.pos2DAttr.count;s++)e.fromBufferAttribute(this.pos2DAttr,s),this.boundingBox2D.expandByPoint(e)}};J(_e,"ATTR_POS2D","pos2d");let Hs=_e;class W{static tubeFromLoop(t,e={}){const{tubularSegments:s=t.size*4,radius:i=.1,radialSegments:n=8,closed:r=!0}=e,o=t.fetch(c=>c.pos()),h=new gi(o,r);return new je(h,s,i,n,r)}}J(W,"box",(...t)=>new zs(...t)),J(W,"sphere",(...t)=>new Js(...t)),J(W,"cylinder",(...t)=>new He(...t)),J(W,"plane",(...t)=>new Ls(...t)),J(W,"cone",(...t)=>new _s(...t)),J(W,"torus",(...t)=>new Ws(...t)),J(W,"torusKnot",(...t)=>new Gs(...t)),J(W,"tube",(...t)=>new je(...t)),J(W,"circle",(...t)=>new vs(...t)),J(W,"ring",(...t)=>new Vs(...t)),J(W,"dodecahedron",(...t)=>new Cs(...t)),J(W,"icosahedron",(...t)=>new Rs(...t)),J(W,"octahedron",(...t)=>new Ds(...t)),J(W,"tetrahedron",(...t)=>new Us(...t)),J(W,"polyhedron",(...t)=>new Zt(...t)),J(W,"lathe",(...t)=>new Ns(...t)),J(W,"shape",(...t)=>new qs(...t)),J(W,"extrude",(...t)=>new Os(...t)),J(W,"capsule",(...t)=>new Ss(...t)),J(W,"point",(...t)=>new er(...t)),J(W,"line",(...t)=>new ir(...t)),J(W,"tri",(...t)=>new rr(...t)),J(W,"verts",(...t)=>new sr(...t)),J(W,"edges",(...t)=>new nr(...t)),J(W,"faces",(...t)=>new or(...t)),J(W,"coplane",(...t)=>new Hs(...t));class Zs{constructor(t,e){J(this,"point");J(this,"direction");this.point=t.clone(),this.direction=e.clone().normalize()}at(t){return this.direction.clone().multiplyScalar(t).add(this.point)}closestPointTo(t){const s=t.clone().sub(this.point).dot(this.direction);return this.at(s)}distanceTo(t){return t.distanceTo(this.closestPointTo(t))}contains(t,e=.01){return this.closestPointTo(t).distanceToSquared(t)<e*e}static fromPoints(t,e){return new Zs(t,e.clone().sub(t))}toSegment(t,e){return new Qn(this.at(t),this.at(e))}equals(t,e=1e-5){return this.direction.clone().cross(t.direction).lengthSq()>e*e?!1:t.point.clone().sub(this.point).cross(this.direction).lengthSq()<e*e}}class it{static createNormalLine(t){const e=t.tri();return new Zs(e.getMidpoint(new b),e.getNormal(new b))}static combineGroupGeometries(t){const e=[];return t.traverse(i=>{const n=i;if(n.isMesh){const r=n.geometry.clone().applyMatrix4(n.matrixWorld);e.push(r)}}),Di(e)}static canonicalize(t){hr(t);const e=t.attributes.position,s=t.index,i=new Map,n=[],r=[],o=new b;for(let a=0;a<s.count;a++){const u=s.getX(a);o.fromBufferAttribute(e,u);const d=ar(o);let p=i.get(d);p===void 0&&(p=n.length,i.set(d,p),n.push(o.clone())),r.push(p)}const h=new Float32Array(n.length*3);for(let a=0;a<n.length;a++){const u=n[a];h[a*3+0]=u.x,h[a*3+1]=u.y,h[a*3+2]=u.z}const c=new V;return c.setAttribute("position",new H(h,3)),c.setIndex(r),c.computeVertexNormals(),c}static createSequentialIndicesAttr(t){const e=new Uint32Array(t);for(let s=0;s<t;s++)e[s]=s;return new H(e,1)}static mergeGeometries(t){const e=Di(t);if(!e)throw new Error("Merge failed");return e}static mergeIndexedGeometries(t){return this.mergeGeometries(t)}static createIndexedGeometry(t){return Kn(t)}static createWireframe(t){return new jn(t)}static createEdgeLoopGeometry(t){const e=new Float32Array(t.size*3);let s=0;for(const r of t.fetch())r.pos().toArray(e,s),s+=3;const i=new Uint32Array((t.size-1)*2);for(let r=0;r<t.size-1;r++)i[r*2]=r,i[r*2+1]=r+1;const n=new V;return n.attributes.position=new H(e,3),n.setIndex(new H(i,1)),n}static isCoplanar(t,e,s=.02,i=.5){return new xi().setFromCoplanarPoints(t.a,t.b,t.c).normal.angleTo(e.normal)<i?Math.abs(e.distanceToPoint(t.a))<s&&Math.abs(e.distanceToPoint(t.b))<s&&Math.abs(e.distanceToPoint(t.c))<s:!1}static extractSubGeometry(t){const e=W.faces(t),i=t.parent.src,n=t.size;if(!i.attributes.uv)return e;const r=i.attributes.uv,o=new Float32Array(n*6),h=new T;let c=0;for(const a of t.fetch())for(const u of a.verts().fetch())r&&(h.fromBufferAttribute(r,u.index),h.toArray(o,c*2)),c++;return e.attributes.uv=new H(o,2),e}static extractSubMesh(t,e){const s=t.geometry,i=s.attributes,n=new Map,r=[];let o=0;for(const f of e.fetch()){const m=f.indices();for(const y of m)n.has(y)||n.set(y,o++);m.forEach(y=>r.push(n.get(y)))}const h=new Map;for(const[f,m]of n.entries())h.set(m,f);const c=new V;for(const[f,m]of Object.entries(i)){const y=m.itemSize,M=m.array.constructor,g=new M(n.size*y);for(let w=0;w<n.size;w++){const x=h.get(w);for(let z=0;z<y;z++)g[w*y+z]=m.array[x*y+z]}c.setAttribute(f,new H(g,y,m.normalized))}const a=s.index.array.constructor,u=new a(r);c.setIndex(new H(u,1));const d=new di({map:t.material.map,side:2});return new mn(c,d)}static async run(t,...e){const s=new tr;return new Promise((i,n)=>{s.onmessage=r=>{r.data.error?n(r.data.error):i(it.deserializeAsType(r.data.result))},s.onerror=n,it.serializeAll(e),s.postMessage({fn:t,payload:e})})}static serialize(t){const e={attributes:{},index:null,groups:t.groups,drawRange:t.drawRange};for(const s in t.attributes){const i=t.attributes[s];e.attributes[s]={array:i.array,itemSize:i.itemSize,normalized:i.normalized}}return t.index&&(e.index={array:t.index.array}),e}static deserialize(t){const e=new V;for(const s in t.attributes){const i=t.attributes[s];e.setAttribute(s,new H(i.array,i.itemSize,i.normalized))}return t.index&&e.setIndex(new H(t.index.array,1)),t.groups&&(e.groups=t.groups),t.drawRange&&(e.drawRange=t.drawRange),e}static isSerializedGeometry(t){return t&&typeof t=="object"&&t.attributes&&t.attributes.position&&t.attributes.position.array instanceof Float32Array&&typeof t.attributes.position.itemSize=="number"}static isSerializedMap(t){return Array.isArray(t)&&t.every(e=>Array.isArray(e)&&e.length===2)}static isSerializedEdgeMap(t){return it.isSerializedMap(t)}static serializeAsType(t){return t instanceof V?it.serialize(t):t instanceof Map?Array.from(t.entries()):t}static deserializeAsType(t){return it.isSerializedGeometry(t)?it.deserialize(t):it.isSerializedEdgeMap(t)?new Map(t):t}static deserializeAll(t){t.forEach((e,s)=>{t[s]=it.deserializeAsType(e)})}static serializeAll(t){t.forEach((e,s)=>{t[s]=it.serializeAsType(e)})}}function hr(l){if(!l.index)throw new Error("Geometry must be indexed.")}function ar(l){return`${l.x.toFixed(5)}_${l.y.toFixed(5)}_${l.z.toFixed(5)}`}self.onmessage=l=>{const{fn:t,payload:e}=l.data;if(typeof it[t]=="function"){const s=it[t];it.deserializeAll(e);const i=it.serializeAsType(s(...e));self.postMessage({result:i})}else self.postMessage({error:`Unknown function: ${t}`})}})();
